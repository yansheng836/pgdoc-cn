<!-- doc/src/sgml/maintenance.sgml -->

<chapter id="maintenance">
<!-- pgdoc-cn_start sig_en=58dcd06ab890ea9c4fecc0aca517ab82 sig_cn_org=None source=14.1 
 <title>Routine Database Maintenance Tasks</title>
________________________________________________________-->
 <title>日常数据库维护工作</title>
<!-- pgdoc-cn_end sig_en=58dcd06ab890ea9c4fecc0aca517ab82 -->

<!-- pgdoc-cn_start sig_en=919a6b2bc909b3e5a4e0bd6c4b9681d2 sig_cn_org=None source=14.1 
 <indexterm zone="maintenance">
  <primary>maintenance</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="maintenance">
  <primary>维护</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=919a6b2bc909b3e5a4e0bd6c4b9681d2 -->

<!-- pgdoc-cn_start sig_en=90a01685f5bfedc92bf7eb3930a12574 sig_cn_org=None source=14.1 
 <indexterm zone="maintenance">
  <primary>routine maintenance</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="maintenance">
  <primary>日常维护</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=90a01685f5bfedc92bf7eb3930a12574 -->

<!-- pgdoc-cn_start sig_en=f0139ada40c64f8029817ce88ed11ae6 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname>, like any database software, requires that certain tasks
   be performed regularly to achieve optimum performance. The tasks
   discussed here are <emphasis>required</emphasis>, but they
   are repetitive in nature and can easily be automated using standard
   tools such as <application>cron</application> scripts or
   Windows' <application>Task Scheduler</application>.  It is the database
   administrator's responsibility to set up appropriate scripts, and to
   check that they execute successfully.
  </para>
________________________________________________________-->
  <para>
   和任何数据库软件一样，<productname>PostgreSQL</productname>需要定期执行特定的任务来达到最优的性能。这里讨论的任务是<emphasis>必需的</emphasis>，但它们本质上是重复性的并且可以很容易使用<application>cron</application>脚本或Windows的<application>任务计划程序</application>等标准工具来自动进行。建立合适的脚本并检查它们是否成功运行是数据库管理员的职责。
  </para>
<!-- pgdoc-cn_end sig_en=f0139ada40c64f8029817ce88ed11ae6 -->

<!-- pgdoc-cn_start sig_en=0f7eeeb8c46a383e680a70576515d46c sig_cn_org=None source=14.1 
  <para>
   One obvious maintenance task is the creation of backup copies of the data on a
   regular schedule.  Without a recent backup, you have no chance of recovery
   after a catastrophe (disk failure, fire, mistakenly dropping a critical
   table, etc.).  The backup and recovery mechanisms available in
   <productname>PostgreSQL</productname> are discussed at length in
   <xref linkend="backup"/>.
  </para>
________________________________________________________-->
  <para>
   一个显而易见的维护任务是定期创建数据的后备拷贝。如果没有一个最近的备份，你就不可能在灾难（磁盘故障、火灾、错误地删除一个关键表等）后进行恢复。<productname>PostgreSQL</productname>中的备份和恢复机制在<xref linkend="backup"/>中有详细的介绍。
  </para>
<!-- pgdoc-cn_end sig_en=0f7eeeb8c46a383e680a70576515d46c -->

<!-- pgdoc-cn_start sig_en=b848f8ee538ce00657e084d3cd42988b sig_cn_org=None source=14.1 
  <para>
   The other main category of maintenance task is periodic <quote>vacuuming</quote>
   of the database.  This activity is discussed in
   <xref linkend="routine-vacuuming"/>.  Closely related to this is updating
   the statistics that will be used by the query planner, as discussed in
   <xref linkend="vacuum-for-statistics"/>.
  </para>
________________________________________________________-->
  <para>
   另一种主要类型的维护任务是周期性地<quote>清理</quote>数据库。该活动在<xref linkend="routine-vacuuming"/>中讨论。与之相关，更新将被查询规划器使用的统计信息的活动将在<xref linkend="vacuum-for-statistics"/>中讨论。
  </para>
<!-- pgdoc-cn_end sig_en=b848f8ee538ce00657e084d3cd42988b -->

<!-- pgdoc-cn_start sig_en=887f16868767b11ead435000a5c50d73 sig_cn_org=None source=14.1 
  <para>
   Another task that might need periodic attention is log file management.
   This is discussed in <xref linkend="logfile-maintenance"/>.
  </para>
________________________________________________________-->
  <para>
   另一项需要周期性考虑的任务是日志文件管理。这在<xref linkend="logfile-maintenance"/>中讨论。
  </para>
<!-- pgdoc-cn_end sig_en=887f16868767b11ead435000a5c50d73 -->

<!-- pgdoc-cn_start sig_en=326c273786fe558fb69752526ad916f0 sig_cn_org=None source=14.1 
  <para>
   <ulink
   url="https://bucardo.org/check_postgres/"><application>check_postgres</application></ulink>
   is available for monitoring database health and reporting unusual
   conditions.  <application>check_postgres</application> integrates with
   Nagios and MRTG, but can be run standalone too.
  </para>
________________________________________________________-->
  <para>
   <ulink
   url="https://bucardo.org/check_postgres/"><application>check_postgres</application></ulink>可用于检测数据库的健康并报告异常情况。<application>check_postgres</application>与Nagios和MRTG整合在一起，但也可以被单独运行。
  </para>
<!-- pgdoc-cn_end sig_en=326c273786fe558fb69752526ad916f0 -->

<!-- pgdoc-cn_start sig_en=611aee55d57e8ef62a11d9b128f92e5e sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> is low-maintenance compared
   to some other database management systems.  Nonetheless,
   appropriate attention to these tasks will go far towards ensuring a
   pleasant and productive experience with the system.
  </para>
________________________________________________________-->
  <para>
   相对于其他数据库管理系统，<productname>PostgreSQL</productname>的维护量较低。但是，适当对这些任务加以注意将大有助于愉快和高效地使用该系统。
  </para>
<!-- pgdoc-cn_end sig_en=611aee55d57e8ef62a11d9b128f92e5e -->

 <sect1 id="routine-vacuuming">
<!-- pgdoc-cn_start sig_en=a1ab8bfa7c7654f337741cbca56de89f sig_cn_org=None source=14.1 
  <title>Routine Vacuuming</title>
________________________________________________________-->
  <title>日常清理</title>
<!-- pgdoc-cn_end sig_en=a1ab8bfa7c7654f337741cbca56de89f -->

<!-- pgdoc-cn_start sig_en=ece0095f7d1109d367131d1fbec0b0aa sig_cn_org=None source=14.1 
  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="routine-vacuuming">
   <primary>清理</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ece0095f7d1109d367131d1fbec0b0aa -->

<!-- pgdoc-cn_start sig_en=36d2d3ac16e50899bf980575cd66a040 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> databases require periodic
   maintenance known as <firstterm>vacuuming</firstterm>.  For many installations, it
   is sufficient to let vacuuming be performed by the <firstterm>autovacuum
   daemon</firstterm>, which is described in <xref linkend="autovacuum"/>.  You might
   need to adjust the autovacuuming parameters described there to obtain best
   results for your situation.  Some database administrators will want to
   supplement or replace the daemon's activities with manually-managed
   <command>VACUUM</command> commands, which typically are executed according to a
   schedule by <application>cron</application> or <application>Task
   Scheduler</application> scripts.  To set up manually-managed vacuuming properly,
   it is essential to understand the issues discussed in the next few
   subsections.  Administrators who rely on autovacuuming may still wish
   to skim this material to help them understand and adjust autovacuuming.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>数据库要求周期性的<firstterm>清理</firstterm>维护。对于很多安装，让<firstterm>自动清理守护进程</firstterm>来执行清理已经足够，如<xref linkend="autovacuum"/>所述。你可能需要调整其中描述的自动清理参数来获得最佳结果。某些数据库管理员会希望使用手动管理的<command>VACUUM</command>命令来对后台进程的活动进行补充或者替换，这通常使用<application>cron</application>或<application>任务计划程序</application>脚本来执行。要正确地设置手动管理的清理，最重要的是理解接下来几小节中讨论的问题。依赖自动清理的管理员最好也能略读该内容以帮助他们理解和调整自动清理。
  </para>
<!-- pgdoc-cn_end sig_en=36d2d3ac16e50899bf980575cd66a040 -->

  <sect2 id="vacuum-basics">
<!-- pgdoc-cn_start sig_en=ad0e435e43c220fb6a4d57a2ee32c8fc sig_cn_org=None source=14.1 
   <title>Vacuuming Basics</title>
________________________________________________________-->
   <title>清理的基础知识</title>
<!-- pgdoc-cn_end sig_en=ad0e435e43c220fb6a4d57a2ee32c8fc -->

<!-- pgdoc-cn_start sig_en=a5122419860e6c3527d1a87375fc2fb6 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname>'s
    <link linkend="sql-vacuum"><command>VACUUM</command></link> command has to
    process each table on a regular basis for several reasons:

    <orderedlist>
     <listitem>
      <simpara>To recover or reuse disk space occupied by updated or deleted
      rows.</simpara>
     </listitem>

     <listitem>
      <simpara>To update data statistics used by the
      <productname>PostgreSQL</productname> query planner.</simpara>
     </listitem>

     <listitem>
      <simpara>To update the visibility map, which speeds
      up <link linkend="indexes-index-only-scans">index-only
      scans</link>.</simpara>
     </listitem>

     <listitem>
      <simpara>To protect against loss of very old data due to
      <firstterm>transaction ID wraparound</firstterm> or
      <firstterm>multixact ID wraparound</firstterm>.</simpara>
     </listitem>
    </orderedlist>

    Each of these reasons dictates performing <command>VACUUM</command> operations
    of varying frequency and scope, as explained in the following subsections.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的 <link linkend="sql-vacuum"><command>VACUUM</command></link>命令出于几个原因必须定期处理每一个表：

    <orderedlist>
     <listitem>
      <simpara>恢复或重用被已更新或已删除行所占用的磁盘空间。</simpara>
     </listitem>

     <listitem>
      <simpara>更新被<productname>PostgreSQL</productname>查询规划器使用的数据统计信息。</simpara>
     </listitem>

     <listitem>
      <simpara>更新可见性映射，它可以加速只用索引的扫描。</simpara>
     </listitem>

     <listitem>
      <simpara>保护老旧数据不会由于<firstterm>事务ID回卷</firstterm>或<firstterm>多事务ID回卷</firstterm>而丢失。</simpara>
     </listitem>
    </orderedlist>

    正如后续小节中解释的，每一个原因都将指示以不同的频率和范围执行<command>VACUUM</command>操作。
   </para>
<!-- pgdoc-cn_end sig_en=a5122419860e6c3527d1a87375fc2fb6 -->

<!-- pgdoc-cn_start sig_en=655972b2f56dd7e1648d8680c08f9b2f sig_cn_org=None source=14.1 
   <para>
    There are two variants of <command>VACUUM</command>: standard <command>VACUUM</command>
    and <command>VACUUM FULL</command>.  <command>VACUUM FULL</command> can reclaim more
    disk space but runs much more slowly.  Also,
    the standard form of <command>VACUUM</command> can run in parallel with production
    database operations.  (Commands such as <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> will continue to function normally, though you
    will not be able to modify the definition of a table with commands such as
    <command>ALTER TABLE</command> while it is being vacuumed.)
    <command>VACUUM FULL</command> requires an
    <literal>ACCESS EXCLUSIVE</literal> lock on the table it is
    working on, and therefore cannot be done in parallel with other use
    of the table.  Generally, therefore,
    administrators should strive to use standard <command>VACUUM</command> and
    avoid <command>VACUUM FULL</command>.
   </para>
________________________________________________________-->
   <para>
    有两种<command>VACUUM</command>的变体：标准<command>VACUUM</command>和<command>VACUUM FULL</command>。<command>VACUUM FULL</command>可以收回更多磁盘空间但是运行起来更慢。另外，标准形式的<command>VACUUM</command>可以和生产数据库操作并行运行（<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>等命令将继续正常工作，但在清理期间你无法使用<command>ALTER TABLE</command>等命令来更新表的定义）。<command>VACUUM FULL</command>要求在其工作的表上得到一个<literal>ACCESS EXCLUSIVE</literal> 锁，因此无法和对此表的其他使用并行。因此，通常管理员应该努力使用标准<command>VACUUM</command>并且避免<command>VACUUM FULL</command>。
   </para>
<!-- pgdoc-cn_end sig_en=655972b2f56dd7e1648d8680c08f9b2f -->

<!-- pgdoc-cn_start sig_en=7408c01a5db2aeeb5acb11cf6bcf3215 sig_cn_org=None source=14.1 
   <para>
    <command>VACUUM</command> creates a substantial amount of I/O
    traffic, which can cause poor performance for other active sessions.
    There are configuration parameters that can be adjusted to reduce the
    performance impact of background vacuuming &mdash; see
    <xref linkend="runtime-config-resource-vacuum-cost"/>.
   </para>
________________________________________________________-->
   <para>
    <command>VACUUM</command>会产生大量I/O流量，这将导致其他活动会话性能变差。可以调整一些配置参数来后台清理活动造成的性能冲击 &mdash; 参阅<xref linkend="runtime-config-resource-vacuum-cost"/>。
   </para>
<!-- pgdoc-cn_end sig_en=7408c01a5db2aeeb5acb11cf6bcf3215 -->
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
<!-- pgdoc-cn_start sig_en=149b089e6d686873ae7d53095efeca4d sig_cn_org=None source=14.1 
   <title>Recovering Disk Space</title>
________________________________________________________-->
   <title>恢复磁盘空间</title>
<!-- pgdoc-cn_end sig_en=149b089e6d686873ae7d53095efeca4d -->

<!-- pgdoc-cn_start sig_en=1389c16d6e0a769532d14a8faaa03b39 sig_cn_org=None source=14.1 
   <indexterm zone="vacuum-for-space-recovery">
    <primary>disk space</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="vacuum-for-space-recovery">
    <primary>disk space</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1389c16d6e0a769532d14a8faaa03b39 -->

<!-- pgdoc-cn_start sig_en=4403f05d9c83aab25ad9b14c436ec0c2 sig_cn_org=None source=14.1 
   <para>
    In <productname>PostgreSQL</productname>, an
    <command>UPDATE</command> or <command>DELETE</command> of a row does not
    immediately remove the old version of the row.
    This approach is necessary to gain the benefits of multiversion
    concurrency control (<acronym>MVCC</acronym>, see <xref linkend="mvcc"/>): the row version
    must not be deleted while it is still potentially visible to other
    transactions. But eventually, an outdated or deleted row version is no
    longer of interest to any transaction. The space it occupies must then be
    reclaimed for reuse by new rows, to avoid unbounded growth of disk
    space requirements. This is done by running <command>VACUUM</command>.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中，一次行的<command>UPDATE</command>或<command>DELETE</command>不会立即移除该行的旧版本。这种方法对于从多版本并发控制（<acronym>MVCC</acronym>，见<xref linkend="mvcc"/>）获益是必需的：当旧版本仍可能对其他事务可见时，它不能被删除。但是最后，任何事务都不会再对一个过时的或者被删除的行版本感兴趣。它所占用的空间必须被回收来用于新行，这样可避免磁盘空间需求的无限制增长。这通过运行<command>VACUUM</command>完成。
   </para>
<!-- pgdoc-cn_end sig_en=4403f05d9c83aab25ad9b14c436ec0c2 -->

<!-- pgdoc-cn_start sig_en=a932f79368032052bb760613fceb95ec sig_cn_org=None source=14.1 
   <para>
    The standard form of <command>VACUUM</command> removes dead row
    versions in tables and indexes and marks the space available for
    future reuse.  However, it will not return the space to the operating
    system, except in the special case where one or more pages at the
    end of a table become entirely free and an exclusive table lock can be
    easily obtained.  In contrast, <command>VACUUM FULL</command> actively compacts
    tables by writing a complete new version of the table file with no dead
    space.  This minimizes the size of the table, but can take a long time.
    It also requires extra disk space for the new copy of the table, until
    the operation completes.
   </para>
________________________________________________________-->
   <para>
    <command>VACUUM</command>的标准形式移除表和索引中的死亡行版本并将该空间标记为可在未来重用。不过，它将不会把该空间交还给操作系统，除非在特殊的情况中表尾部的一个或多个页面变成完全空闲并且能够很容易地得到一个排他表锁。相反，<command>VACUUM FULL</command>通过把死亡空间之外的内容写成一个完整的新版本表文件来主动紧缩表。这将最小化表的尺寸，但是要花较长的时间。它也需要额外的磁盘空间用于表的新副本，直到操作完成。
   </para>
<!-- pgdoc-cn_end sig_en=a932f79368032052bb760613fceb95ec -->

<!-- pgdoc-cn_start sig_en=e4f98aaa39c620bf56244c7676b6c52d sig_cn_org=None source=14.1 
   <para>
    The usual goal of routine vacuuming is to do standard <command>VACUUM</command>s
    often enough to avoid needing <command>VACUUM FULL</command>.  The
    autovacuum daemon attempts to work this way, and in fact will
    never issue <command>VACUUM FULL</command>.  In this approach, the idea
    is not to keep tables at their minimum size, but to maintain steady-state
    usage of disk space: each table occupies space equivalent to its
    minimum size plus however much space gets used up between vacuum runs.
    Although <command>VACUUM FULL</command> can be used to shrink a table back
    to its minimum size and return the disk space to the operating system,
    there is not much point in this if the table will just grow again in the
    future.  Thus, moderately-frequent standard <command>VACUUM</command> runs are a
    better approach than infrequent <command>VACUUM FULL</command> runs for
    maintaining heavily-updated tables.
   </para>
________________________________________________________-->
   <para>
    例行清理的一般目标是多做标准的<command>VACUUM</command>来避免需要<command>VACUUM FULL</command>。自动清理守护进程尝试这样工作，并且实际上永远不会发出<command>VACUUM FULL</command>。在这种方法中，其思想不是让表保持它们的最小尺寸，而是保持磁盘空间使用的稳定状态：每个表占用的空间等于其最小尺寸外加清理之间将使用的空间量。尽管<command>VACUUM FULL</command>可被用来把一个表收缩回它的最小尺寸并将该磁盘空间交还给操作系统，但是如果该表将在未来再次增长这样就没什么意义。因此，对于维护频繁被更新的表，适度运行标准<command>VACUUM</command>运行比少量运行<command>VACUUM FULL</command>要更好。
   </para>
<!-- pgdoc-cn_end sig_en=e4f98aaa39c620bf56244c7676b6c52d -->

<!-- pgdoc-cn_start sig_en=4d734c89f5b7a98526873bffa8257748 sig_cn_org=None source=14.1 
   <para>
    Some administrators prefer to schedule vacuuming themselves, for example
    doing all the work at night when load is low.
    The difficulty with doing vacuuming according to a fixed schedule
    is that if a table has an unexpected spike in update activity, it may
    get bloated to the point that <command>VACUUM FULL</command> is really necessary
    to reclaim space.  Using the autovacuum daemon alleviates this problem,
    since the daemon schedules vacuuming dynamically in response to update
    activity.  It is unwise to disable the daemon completely unless you
    have an extremely predictable workload.  One possible compromise is
    to set the daemon's parameters so that it will only react to unusually
    heavy update activity, thus keeping things from getting out of hand,
    while scheduled <command>VACUUM</command>s are expected to do the bulk of the
    work when the load is typical.
   </para>
________________________________________________________-->
   <para>
    一些管理员更喜欢自己计划清理，例如在晚上负载低时做所有的工作。根据一个固定日程来做清理的难点在于，如果一个表有一次预期之外的更新活动尖峰，它可能膨胀得真正需要<command>VACUUM FULL</command>来回收空间。使用自动清理守护进程可以减轻这个问题，因为守护进程会根据更新活动动态规划清理操作。除非你的负载是完全可以预估的，完全禁用守护进程是不理智的。一种可能的折中方案是设置守护进程的参数，这样它将只对异常的大量更新活动做出反应，因而保证事情不会失控，而在负载正常时采用有计划的<command>VACUUM</command>来做批量工作。
   </para>
<!-- pgdoc-cn_end sig_en=4d734c89f5b7a98526873bffa8257748 -->

<!-- pgdoc-cn_start sig_en=3087b802996826cce22c5d78e92b6506 sig_cn_org=None source=14.1 
   <para>
    For those not using autovacuum, a typical approach is to schedule a
    database-wide <command>VACUUM</command> once a day during a low-usage period,
    supplemented by more frequent vacuuming of heavily-updated tables as
    necessary. (Some installations with extremely high update rates vacuum
    their busiest tables as often as once every few minutes.) If you have
    multiple databases in a cluster, don't forget to
    <command>VACUUM</command> each one; the program <xref
    linkend="app-vacuumdb"/> might be helpful.
   </para>
________________________________________________________-->
   <para>
    对于那些不使用自动清理的用户，一种典型的方法是计划一个数据库范围的<command>VACUUM</command>，该操作每天在低使用量时段执行一次，并根据需要辅以在重度更新表上的更频繁的清理（一些有着极高更新率的安装会每几分钟清理一次它们的最繁忙的表）。如果你在一个集簇中有多个数据库，别忘记<command>VACUUM</command>每一个，你会用得上<xref linkend="app-vacuumdb"/>程序。
   </para>
<!-- pgdoc-cn_end sig_en=3087b802996826cce22c5d78e92b6506 -->

   <tip>
<!-- pgdoc-cn_start sig_en=e3011bf16617e71596ef5ae368d032c4 sig_cn_org=None source=14.1 
   <para>
    Plain <command>VACUUM</command> may not be satisfactory when
    a table contains large numbers of dead row versions as a result of
    massive update or delete activity.  If you have such a table and
    you need to reclaim the excess disk space it occupies, you will need
    to use <command>VACUUM FULL</command>, or alternatively
    <link linkend="sql-cluster"><command>CLUSTER</command></link>
    or one of the table-rewriting variants of
    <link linkend="sql-altertable"><command>ALTER TABLE</command></link>.
    These commands rewrite an entire new copy of the table and build
    new indexes for it.  All these options require an
    <literal>ACCESS EXCLUSIVE</literal> lock.  Note that
    they also temporarily use extra disk space approximately equal to the size
    of the table, since the old copies of the table and indexes can't be
    released until the new ones are complete.
   </para>
________________________________________________________-->
   <para>
    当一个表因为大量更新或删除活动而包含大量死亡行版本时，纯粹的<command>VACUUM</command>可能不能令人满意。如果你有这样一个表并且你需要回收它占用的过量磁盘空间，你将需要使用<command>VACUUM FULL</command>，或者<link linkend="sql-cluster"><command>CLUSTER</command></link>，或者<link linkend="sql-altertable"><command>ALTER TABLE</command></link>的表重写变体之一。这些命令重写该表的一整个新拷贝并且为它构建新索引。所有这些选项都要求<literal>ACCESS EXCLUSIVE</literal> 锁。注意它们也临时使用大约等于该表尺寸的额外磁盘空间，因为直到新表和索引完成之前旧表和索引都不能被释放。
   </para>
<!-- pgdoc-cn_end sig_en=e3011bf16617e71596ef5ae368d032c4 -->
   </tip>

   <tip>
<!-- pgdoc-cn_start sig_en=c2af4523b6ec4a95263c702b61f56401 sig_cn_org=None source=14.1 
   <para>
    If you have a table whose entire contents are deleted on a periodic
    basis, consider doing it with
    <link linkend="sql-truncate"><command>TRUNCATE</command></link> rather
    than using <command>DELETE</command> followed by
    <command>VACUUM</command>. <command>TRUNCATE</command> removes the
    entire content of the table immediately, without requiring a
    subsequent <command>VACUUM</command> or <command>VACUUM
    FULL</command> to reclaim the now-unused disk space.
    The disadvantage is that strict MVCC semantics are violated.
   </para>
________________________________________________________-->
   <para>
    如果你有一个表，它的整个内容会被周期性删除，考虑用<link linkend="sql-truncate"><command>TRUNCATE</command></link>而不是先用<command>DELETE</command>再用<command>VACUUM</command>。<command>TRUNCATE</command>会立刻移除该表的整个内容，而不需要一次后续的<command>VACUUM</command>或<command>VACUUM FULL</command>来回收现在未被使用的磁盘空间。其缺点是会违背严格的 MVCC 语义。
   </para>
<!-- pgdoc-cn_end sig_en=c2af4523b6ec4a95263c702b61f56401 -->
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
<!-- pgdoc-cn_start sig_en=f909c781f2200938cd5cb2b888ab09c3 sig_cn_org=None source=14.1 
   <title>Updating Planner Statistics</title>
________________________________________________________-->
   <title>更新规划器统计信息</title>
<!-- pgdoc-cn_end sig_en=f909c781f2200938cd5cb2b888ab09c3 -->

<!-- pgdoc-cn_start sig_en=a91010fad004a381d52c8981e7fe6be6 sig_cn_org=None source=14.1 
   <indexterm zone="vacuum-for-statistics">
    <primary>statistics</primary>
    <secondary>of the planner</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="vacuum-for-statistics">
    <primary>statistics</primary>
    <secondary>of the planner</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a91010fad004a381d52c8981e7fe6be6 -->

<!-- pgdoc-cn_start sig_en=ba3a9f2cca056ef1a0c12ed7186f6b94 sig_cn_org=None source=14.1 
   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ba3a9f2cca056ef1a0c12ed7186f6b94 -->

<!-- pgdoc-cn_start sig_en=8fcbe604c918ef3f5352a7dc97b79453 sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> query planner relies on
    statistical information about the contents of tables in order to
    generate good plans for queries.  These statistics are gathered by
    the <link linkend="sql-analyze"><command>ANALYZE</command></link> command,
    which can be invoked by itself or
    as an optional step in <command>VACUUM</command>.  It is important to have
    reasonably accurate statistics, otherwise poor choices of plans might
    degrade database performance.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>查询规划器依赖于有关表内容的统计信息来为查询产生好的计划。这些统计信息由<link linkend="sql-analyze"><command>ANALYZE</command></link>命令收集，它除了直接被调用之外还可以作为<command>VACUUM</command>的一个可选步骤被调用。拥有适度准确的统计信息很重要，否则差的计划可能降低数据库性能。
   </para>
<!-- pgdoc-cn_end sig_en=8fcbe604c918ef3f5352a7dc97b79453 -->

<!-- pgdoc-cn_start sig_en=47c6bbb1037cb0c78206361ecc8fe807 sig_cn_org=None source=14.1 
   <para>
    The autovacuum daemon, if enabled, will automatically issue
    <command>ANALYZE</command> commands whenever the content of a table has
    changed sufficiently.  However, administrators might prefer to rely
    on manually-scheduled <command>ANALYZE</command> operations, particularly
    if it is known that update activity on a table will not affect the
    statistics of <quote>interesting</quote> columns.  The daemon schedules
    <command>ANALYZE</command> strictly as a function of the number of rows
    inserted or updated; it has no knowledge of whether that will lead
    to meaningful statistical changes.
   </para>
________________________________________________________-->
   <para>
    自动清理守护进程如果被启用，当一个表的内容被改变得足够多时，它将自动发出<command>ANALYZE</command>命令。不过，管理员可能更喜欢依靠手动的<command>ANALYZE</command>操作，特别是如果知道一个表上的更新活动将不会影响<quote>感兴趣的</quote>列的统计信息时。守护进程严格地按照一个被插入或更新行数的函数来计划<command>ANALYZE</command>，它不知道那是否将导致有意义的统计信息改变。
   </para>
<!-- pgdoc-cn_end sig_en=47c6bbb1037cb0c78206361ecc8fe807 -->

<!-- pgdoc-cn_start sig_en=d0190cf0a7e9fe4bed8f613193d92916 sig_cn_org=44070d7378a8e8cbc27707d0e1407bda source=15.7 
   <para>
    Tuples changed in partitions and inheritance children do not trigger
    analyze on the parent table.  If the parent table is empty or rarely
    changed, it may never be processed by autovacuum, and the statistics for
    the inheritance tree as a whole won't be collected. It is necessary to
    run <command>ANALYZE</command> on the parent table manually in order to
    keep the statistics up to date.
   </para>
________________________________________________________-->
   <para>
    在分区和继承子项中更改的元组不会触发父表上的分析。如果父表为空或很少更改，
    它可能永远不会被自动清理处理，并且整个继承树的统计信息将不会被收集。
    为了保持统计信息最新，需要手动在父表上运行<command>ANALYZE</command>。
</para>
<!-- pgdoc-cn_end sig_en=d0190cf0a7e9fe4bed8f613193d92916 -->

<!-- pgdoc-cn_start sig_en=9cfc6209e62c87391c563a397d07b1f8 sig_cn_org=None source=14.1 
   <para>
    As with vacuuming for space recovery, frequent updates of statistics
    are more useful for heavily-updated tables than for seldom-updated
    ones. But even for a heavily-updated table, there might be no need for
    statistics updates if the statistical distribution of the data is
    not changing much. A simple rule of thumb is to think about how much
    the minimum and maximum values of the columns in the table change.
    For example, a <type>timestamp</type> column that contains the time
    of row update will have a constantly-increasing maximum value as
    rows are added and updated; such a column will probably need more
    frequent statistics updates than, say, a column containing URLs for
    pages accessed on a website. The URL column might receive changes just
    as often, but the statistical distribution of its values probably
    changes relatively slowly.
   </para>
________________________________________________________-->
   <para>
    正如用于空间恢复的清理一样，频繁更新统计信息对重度更新的表更加有用。但即使对于一个重度更新的表，如果该数据的统计分布没有很大改变，也没有必要更新统计信息。一个简单的经验法则是考虑表中列的最大和最小值改变了多少。例如，一个包含行被更新时间的<type>timestamp</type>列将在行被增加和更新时有一直增加的最大值；这样一列将可能需要更频繁的统计更新，而一个包含一个网站上被访问页面 URL 的列则不需要。URL 列可以经常被更改，但是其值的统计分布的变化相对很慢。
   </para>
<!-- pgdoc-cn_end sig_en=9cfc6209e62c87391c563a397d07b1f8 -->

<!-- pgdoc-cn_start sig_en=34acfbeb8927f940d634b17a4932a910 sig_cn_org=None source=14.1 
   <para>
    It is possible to run <command>ANALYZE</command> on specific tables and even
    just specific columns of a table, so the flexibility exists to update some
    statistics more frequently than others if your application requires it.
    In practice, however, it is usually best to just analyze the entire
    database, because it is a fast operation.  <command>ANALYZE</command> uses a
    statistically random sampling of the rows of a table rather than reading
    every single row.
   </para>
________________________________________________________-->
   <para>
    可以在指定表上运行<command>ANALYZE</command>甚至在表的指定列上运行，因此如果你的应用需要，可以更加频繁地更新某些统计。但实际上，通常只分析整个数据库是最好的，因为它是一种很快的操作。<command>ANALYZE</command>对一个表的行使用一种统计的随机采样，而不是读取每一个单一行。
   </para>
<!-- pgdoc-cn_end sig_en=34acfbeb8927f940d634b17a4932a910 -->

   <tip>
<!-- pgdoc-cn_start sig_en=1acaf3d23604abdc85c7e80d567808ce sig_cn_org=None source=14.1 
    <para>
     Although per-column tweaking of <command>ANALYZE</command> frequency might not be
     very productive, you might find it worthwhile to do per-column
     adjustment of the level of detail of the statistics collected by
     <command>ANALYZE</command>.  Columns that are heavily used in <literal>WHERE</literal>
     clauses and have highly irregular data distributions might require a
     finer-grain data histogram than other columns.  See <command>ALTER TABLE
     SET STATISTICS</command>, or change the database-wide default using the <xref
     linkend="guc-default-statistics-target"/> configuration parameter.
    </para>
________________________________________________________-->
    <para>
     尽管对每列的<command>ANALYZE</command>频度调整可能不是非常富有成效，你可能会发现值得为每列调整被<command>ANALYZE</command>收集统计信息的详细程度。经常在<literal>WHERE</literal>中被用到的列以及数据分布非常不规则的列可能需要比其他列更细粒度的数据直方图。见<command>ALTER TABLE SET STATISTICS</command>，或者使用<xref linkend="guc-default-statistics-target"/>配置参数改变数据库范围的默认值。
    </para>
<!-- pgdoc-cn_end sig_en=1acaf3d23604abdc85c7e80d567808ce -->

<!-- pgdoc-cn_start sig_en=49a02a250d1a65cb6c9167611366ea70 sig_cn_org=None source=14.1 
    <para>
     Also, by default there is limited information available about
     the selectivity of functions.  However, if you create a statistics
     object or an expression
     index that uses a function call, useful statistics will be
     gathered about the function, which can greatly improve query
     plans that use the expression index.
    </para>
________________________________________________________-->
    <para>
     还有，默认情况下关于函数的选择度的可用信息是有限的。但是，如果你创建一个统计对象或者使用函数的表达式索引，关于该函数的有用的统计信息将被收集，这些信息能够大大提高使用该表达式索引的查询计划的质量。
    </para>
<!-- pgdoc-cn_end sig_en=49a02a250d1a65cb6c9167611366ea70 -->
   </tip>

   <tip>
<!-- pgdoc-cn_start sig_en=ae4998ab4b2248f65493fafdcc107dbb sig_cn_org=None source=14.1 
    <para>
     The autovacuum daemon does not issue <command>ANALYZE</command> commands for
     foreign tables, since it has no means of determining how often that
     might be useful.  If your queries require statistics on foreign tables
     for proper planning, it's a good idea to run manually-managed
     <command>ANALYZE</command> commands on those tables on a suitable schedule.
    </para>
________________________________________________________-->
    <para>
     自动清理守护进程不会为外部表发出<command>ANALYZE</command>命令，因为无法确定一个合适的频度。如果你的查询需要外部表的统计信息来正确地进行规划，比较好的方式是按照一个合适的时间表在那些表上手工运行<command>ANALYZE</command>命令。
    </para>
<!-- pgdoc-cn_end sig_en=ae4998ab4b2248f65493fafdcc107dbb -->
   </tip>

   <tip>
<!-- pgdoc-cn_start sig_en=ee90ccdd4945a3cf083d997ad6ec9ffe sig_cn_org=64bd71ea4b7fc2f28c6a30d639fb9028 source=15.7 
    <para>
     The autovacuum daemon does not issue <command>ANALYZE</command> commands
     for partitioned tables.  Inheritance parents will only be analyzed if the
     parent itself is changed - changes to child tables do not trigger
     autoanalyze on the parent table.  If your queries require statistics on
     parent tables for proper planning, it is necessary to periodically run
     a manual <command>ANALYZE</command> on those tables to keep the statistics
     up to date.
    </para>
________________________________________________________-->
    <para>
     自动清理守护程序不会为分区表发出<command>ANALYZE</command>命令。只有在父表本身发生更改时，继承父表才会被分析 - 子表的更改不会触发父表的自动分析。
     如果您的查询需要父表的统计信息以进行正确的规划，则有必要定期对这些表运行手动<command>ANALYZE</command>以保持统计信息最新。
    </para>
<!-- pgdoc-cn_end sig_en=ee90ccdd4945a3cf083d997ad6ec9ffe -->
   </tip>

  </sect2>

  <sect2 id="vacuum-for-visibility-map">
<!-- pgdoc-cn_start sig_en=da0d8a8dffa4b16a79c69392f5f317a2 sig_cn_org=None source=14.1 
   <title>Updating the Visibility Map</title>
________________________________________________________-->
   <title>更新可见性映射</title>
<!-- pgdoc-cn_end sig_en=da0d8a8dffa4b16a79c69392f5f317a2 -->

<!-- pgdoc-cn_start sig_en=10b3a5516b718f201da65f851477b8b9 sig_cn_org=None source=14.1 
   <para>
    Vacuum maintains a <link linkend="storage-vm">visibility map</link> for each
    table to keep track of which pages contain only tuples that are known to be
    visible to all active transactions (and all future transactions, until the
    page is again modified).  This has two purposes.  First, vacuum
    itself can skip such pages on the next run, since there is nothing to
    clean up.
   </para>
________________________________________________________-->
   <para>
    清理机制为每一个表维护着一个<link linkend="storage-vm">可见性映射</link>，它被用来跟踪哪些页面只包含对所有活动事务（以及所有未来的事务，直到该页面被再次修改）可见的元组。这样做有两个目的。第一，清理本身可以在下一次运行时跳过这样的页面，因为其中没有什么需要被清除。
   </para>
<!-- pgdoc-cn_end sig_en=10b3a5516b718f201da65f851477b8b9 -->

<!-- pgdoc-cn_start sig_en=f39454f16b2bfa574f4d37f07263bfb9 sig_cn_org=None source=14.1 
   <para>
    Second, it allows <productname>PostgreSQL</productname> to answer some
    queries using only the index, without reference to the underlying table.
    Since <productname>PostgreSQL</productname> indexes don't contain tuple
    visibility information, a normal index scan fetches the heap tuple for each
    matching index entry, to check whether it should be seen by the current
    transaction.
    An <link linkend="indexes-index-only-scans"><firstterm>index-only
    scan</firstterm></link>, on the other hand, checks the visibility map first.
    If it's known that all tuples on the page are
    visible, the heap fetch can be skipped.  This is most useful on
    large data sets where the visibility map can prevent disk accesses.
    The visibility map is vastly smaller than the heap, so it can easily be
    cached even when the heap is very large.
   </para>
________________________________________________________-->
   <para>
    第二，这允许<productname>PostgreSQL</productname>回答一些只用索引的查询，而不需要引用底层表。因为<productname>PostgreSQL</productname>的索引不包含元组的可见性信息，一次普通的索引扫描会为每一个匹配的索引项获取堆元组，用来检查它是否能被当前事务所见。另一方面，一次<firstterm>只用索引的扫描</firstterm>会首先检查可见性映射。如果它了解到在该页面上的所有元组都是可见的，堆获取就可以被跳过。这对大数据集很有用，因为可见性映射可以防止磁盘访问。可见性映射比堆小很多，因此即使堆非常大，可见性映射也可以很容易地被缓存起来。
   </para>
<!-- pgdoc-cn_end sig_en=f39454f16b2bfa574f4d37f07263bfb9 -->
  </sect2>

  <sect2 id="vacuum-for-wraparound">
<!-- pgdoc-cn_start sig_en=b64f3f9a92bb92db3e9c8f7d4767853f sig_cn_org=None source=14.1 
   <title>Preventing Transaction ID Wraparound Failures</title>
________________________________________________________-->
   <title>防止事务 ID 回卷失败</title>
<!-- pgdoc-cn_end sig_en=b64f3f9a92bb92db3e9c8f7d4767853f -->

<!-- pgdoc-cn_start sig_en=2fd2e1e48a31cf3dbcf564c7b1217015 sig_cn_org=None source=14.1 
   <indexterm zone="vacuum-for-wraparound">
    <primary>transaction ID</primary>
    <secondary>wraparound</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="vacuum-for-wraparound">
    <primary>事务 ID</primary>
    <secondary>回卷</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2fd2e1e48a31cf3dbcf564c7b1217015 -->

<!-- pgdoc-cn_start sig_en=e0ddcd25427fc49f7309ae2ad7d1cd15 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>wraparound</primary>
     <secondary>of transaction IDs</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>回卷</primary>
     <secondary>事务 ID 的</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e0ddcd25427fc49f7309ae2ad7d1cd15 -->

<!-- pgdoc-cn_start sig_en=5a5cffd3a312fe217ae73d71d1871716 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname>'s
    <link linkend="mvcc-intro">MVCC</link> transaction semantics
    depend on being able to compare transaction ID (<acronym>XID</acronym>)
    numbers: a row version with an insertion XID greater than the current
    transaction's XID is <quote>in the future</quote> and should not be visible
    to the current transaction.  But since transaction IDs have limited size
    (32 bits) a cluster that runs for a long time (more
    than 4 billion transactions) would suffer <firstterm>transaction ID
    wraparound</firstterm>: the XID counter wraps around to zero, and all of a sudden
    transactions that were in the past appear to be in the future &mdash; which
    means their output become invisible.  In short, catastrophic data loss.
    (Actually the data is still there, but that's cold comfort if you cannot
    get at it.)  To avoid this, it is necessary to vacuum every table
    in every database at least once every two billion transactions.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的 MVCC 事务语义依赖于能够比较事务 ID（<acronym>XID</acronym>）数字：如果一个行版本的插入 XID 大于当前事务的 XID，它就是<quote>属于未来的</quote>并且不应该对当前事务可见。但是因为事务 ID 的尺寸有限（32位），一个长时间（超过 40 亿个事务）运行的集簇会遭受到<firstterm>事务 ID 回卷</firstterm>问题：XID 计数器回卷到 0，并且本来属于过去的事务突然间就变成了属于未来 &mdash; 这意味着它们的输出变成不可见。简而言之，灾难性的数据丢失（实际上数据仍然在那里，但是如果你不能得到它也无济于事）。为了避免发生这种情况，有必要至少每 20 亿个事务就清理每个数据库中的每个表。
   </para>
<!-- pgdoc-cn_end sig_en=5a5cffd3a312fe217ae73d71d1871716 -->

<!-- pgdoc-cn_start sig_en=a2bbffafcdbcb0ed126fe2150b7542f4 sig_cn_org=None source=14.1 
   <para>
    The reason that periodic vacuuming solves the problem is that
    <command>VACUUM</command> will mark rows as <emphasis>frozen</emphasis>, indicating that
    they were inserted by a transaction that committed sufficiently far in
    the past that the effects of the inserting transaction are certain to be
    visible to all current and future transactions.
    Normal XIDs are
    compared using modulo-2<superscript>32</superscript> arithmetic. This means
    that for every normal XID, there are two billion XIDs that are
    <quote>older</quote> and two billion that are <quote>newer</quote>; another
    way to say it is that the normal XID space is circular with no
    endpoint. Therefore, once a row version has been created with a particular
    normal XID, the row version will appear to be <quote>in the past</quote> for
    the next two billion transactions, no matter which normal XID we are
    talking about. If the row version still exists after more than two billion
    transactions, it will suddenly appear to be in the future. To
    prevent this, <productname>PostgreSQL</productname> reserves a special XID,
    <literal>FrozenTransactionId</literal>, which does not follow the normal XID
    comparison rules and is always considered older
    than every normal XID.
    Frozen row versions are treated as if the inserting XID were
    <literal>FrozenTransactionId</literal>, so that they will appear to be
    <quote>in the past</quote> to all normal transactions regardless of wraparound
    issues, and so such row versions will be valid until deleted, no matter
    how long that is.
   </para>
________________________________________________________-->
   <para>
    周期性的清理能够解决该问题的原因是，<command>VACUUM</command>会把行标记为
    <emphasis>冻结</emphasis>，这表示它们是被一个在足够远的过去提交的事务所插入，
    这样从 MVCC 的角度来看，效果就是该插入事务对所有当前和未来事务来说当然都
    是可见的。<productname>PostgreSQL</productname>保留了一个特殊的 XID 
    （<literal>FrozenTransactionId</literal>），这个 XID 并不遵循普通 XID 的比较规则
    并且总是被认为比任何普通 XID 要老。普通 XID 使用模-2<superscript>32</superscript>算
    法来比较。这意味着对于每一个普通 XID都有 20 亿个 XID <quote>更老</quote>并且
    有 20 亿个<quote>更新</quote>，另一种解释的方法是普通 XID 空间是没有端点的环。
    因此，一旦一个行版本创建时被分配了一个特定的普通 XID，该行版本将成为接下
    来 20 亿个事务的<quote>过去</quote>（与我们谈论的具体哪个普通 XID 无关）。如
    果在 20 亿个事务之后该行版本仍然存在，它将突然变得好像在未来。要阻止这一切
    发生，被冻结行版本会被看成其插入 XID 为<literal>FrozenTransactionId</literal>，
    这样它们对所有普通事务来说都是<quote>在过去</quote>，而不管回卷问题。并且这样
    的行版本将一直有效直到被删除，不管它有多旧。
   </para>
<!-- pgdoc-cn_end sig_en=a2bbffafcdbcb0ed126fe2150b7542f4 -->

   <note>
<!-- pgdoc-cn_start sig_en=fa74e31055a3baf663a9daf77f3706be sig_cn_org=None source=14.1 
    <para>
     In <productname>PostgreSQL</productname> versions before 9.4, freezing was
     implemented by actually replacing a row's insertion XID
     with <literal>FrozenTransactionId</literal>, which was visible in the
     row's <structname>xmin</structname> system column.  Newer versions just set a flag
     bit, preserving the row's original <structname>xmin</structname> for possible
     forensic use.  However, rows with <structname>xmin</structname> equal
     to <literal>FrozenTransactionId</literal> (2) may still be found
     in databases <application>pg_upgrade</application>'d from pre-9.4 versions.
    </para>
________________________________________________________-->
    <para>
     在9.4之前的<productname>PostgreSQL</productname>版本中，实际上会通过将一行的插入 XID 替换为
     <literal>FrozenTransactionId</literal>来实现冻结，这种FrozenTransactionId在行的
     <structname>xmin</structname>系统列中是可见的。较新的版本只是设置一个标志位，
     保留行的原始<structname>xmin</structname>用于可能发生的鉴别用途。不过，
     在9.4之前版本的数据库<application>pg_upgrade</application>中可能仍会找到
     <structname>xmin</structname>等于<literal>FrozenTransactionId</literal> (2)的行。
    </para>
<!-- pgdoc-cn_end sig_en=fa74e31055a3baf663a9daf77f3706be -->
<!-- pgdoc-cn_start sig_en=fef71a84a9b749432e9a81a629ffa981 sig_cn_org=None source=14.1 
    <para>
     Also, system catalogs may contain rows with <structname>xmin</structname> equal
     to <literal>BootstrapTransactionId</literal> (1), indicating that they were
     inserted during the first phase of <application>initdb</application>.
     Like <literal>FrozenTransactionId</literal>, this special XID is treated as
     older than every normal XID.
    </para>
________________________________________________________-->
    <para>
     此外，系统目录可能会包含<structname>xmin</structname>等于<literal>BootstrapTransactionId</literal> (1)
     的行，这表示它们是在<application>initdb</application>的第一个阶段被插入的。
     和<literal>FrozenTransactionId</literal>相似，这个特殊的 XID 被认为比所有正常 XID 的年龄都要老。
    </para>
<!-- pgdoc-cn_end sig_en=fef71a84a9b749432e9a81a629ffa981 -->
   </note>

<!-- pgdoc-cn_start sig_en=ac39881828b7c662f1793ed63d023714 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/>
    controls how old an XID value has to be before rows bearing that XID will be
    frozen.  Increasing this setting may avoid unnecessary work if the
    rows that would otherwise be frozen will soon be modified again,
    but decreasing this setting increases
    the number of transactions that can elapse before the table must be
    vacuumed again.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="guc-vacuum-freeze-min-age"/>控制在其行版本被冻结前一个 XID
    值应该有多老。如果被冻结的行将很快会被再次修改，增加这个设置可以避免不必要
    的工作。但是减少这个设置会增加在表必须再次被清理之前能够流逝的事务数。
   </para>
<!-- pgdoc-cn_end sig_en=ac39881828b7c662f1793ed63d023714 -->

<!-- pgdoc-cn_start sig_en=1a1a9ed99b22a350353e3ab7e703709c sig_cn_org=764484d41590575e657b5cd4912017b8 source=15.7 
   <para>
    <command>VACUUM</command> uses the <link linkend="storage-vm">visibility map</link>
    to determine which pages of a table must be scanned.  Normally, it
    will skip pages that don't have any dead row versions even if those pages
    might still have row versions with old XID values.  Therefore, normal
    <command>VACUUM</command>s won't always freeze every old row version in the table.
    When that happens, <command>VACUUM</command> will eventually need to perform an
    <firstterm>aggressive vacuum</firstterm>, which will freeze all eligible unfrozen
    XID and MXID values, including those from all-visible but not all-frozen pages.
    In practice most tables require periodic aggressive vacuuming.
    <xref linkend="guc-vacuum-freeze-table-age"/>
    controls when <command>VACUUM</command> does that: all-visible but not all-frozen
    pages are scanned if the number of transactions that have passed since the
    last such scan is greater than <varname>vacuum_freeze_table_age</varname> minus
    <varname>vacuum_freeze_min_age</varname>. Setting
    <varname>vacuum_freeze_table_age</varname> to 0 forces <command>VACUUM</command> to
    always use its aggressive strategy.
   </para>
________________________________________________________-->
   <para>
    <command>VACUUM</command>使用<link linkend="storage-vm">可见性映射</link>来确定必须扫描哪些表页。
    通常，即使这些页可能仍然具有旧XID值的行版本，也会跳过没有任何死行版本的页。
    因此，通常的<command>VACUUM</command>不会总是冻结表中的每个旧行版本。
    当发生这种情况时，<command>VACUUM</command>最终需要执行<firstterm>积极的清理</firstterm>，
    这将冻结所有符合条件的未冻结XID和MXID值，包括所有可见但未全部冻结的页。
    实际上，大多数表需要定期进行积极的清理。
    <xref linkend="guc-vacuum-freeze-table-age"/>控制<command>VACUUM</command>何时执行此操作：
    如果自上次扫描以来经过的事务数量大于<varname>vacuum_freeze_table_age</varname>减去
    <varname>vacuum_freeze_min_age</varname>，则扫描所有可见但未全部冻结的页。
    将<varname>vacuum_freeze_table_age</varname>设置为0会强制<command>VACUUM</command>始终使用其积极策略。
</para>
<!-- pgdoc-cn_end sig_en=1a1a9ed99b22a350353e3ab7e703709c -->

<!-- pgdoc-cn_start sig_en=dc5c097a320ef43c5668e89f0350e509 sig_cn_org=None source=14.1 
   <para>
    The maximum time that a table can go unvacuumed is two billion
    transactions minus the <varname>vacuum_freeze_min_age</varname> value at
    the time of the last aggressive vacuum. If it were to go
    unvacuumed for longer than
    that, data loss could result.  To ensure that this does not happen,
    autovacuum is invoked on any table that might contain unfrozen rows with
    XIDs older than the age specified by the configuration parameter <xref
    linkend="guc-autovacuum-freeze-max-age"/>.  (This will happen even if
    autovacuum is disabled.)
   </para>
________________________________________________________-->
   <para>
    一个表能保持不被清理的最长时间是 20 亿个事务减去<command>VACUUM</command>上次扫描全表时的<varname>vacuum_freeze_min_age</varname>值。如果它超过该时间没有被清理，可能会导致数据丢失。要保证这不会发生，将在任何包含比<xref linkend="guc-autovacuum-freeze-max-age"/>配置参数所指定的年龄更老的 XID 的未冻结行的表上调用自动清理（即使自动清理被禁用也会发生）。
   </para>
<!-- pgdoc-cn_end sig_en=dc5c097a320ef43c5668e89f0350e509 -->

<!-- pgdoc-cn_start sig_en=c22c25bec0eaf0ea72d29ce1a28c25de sig_cn_org=None source=14.1 
   <para>
    This implies that if a table is not otherwise vacuumed,
    autovacuum will be invoked on it approximately once every
    <varname>autovacuum_freeze_max_age</varname> minus
    <varname>vacuum_freeze_min_age</varname> transactions.
    For tables that are regularly vacuumed for space reclamation purposes,
    this is of little importance.  However, for static tables
    (including tables that receive inserts, but no updates or deletes),
    there is no need to vacuum for space reclamation, so it can
    be useful to try to maximize the interval between forced autovacuums
    on very large static tables.  Obviously one can do this either by
    increasing <varname>autovacuum_freeze_max_age</varname> or decreasing
    <varname>vacuum_freeze_min_age</varname>.
   </para>
________________________________________________________-->
   <para>
    这意味着如果一个表没有被清理，大约每<varname>autovacuum_freeze_max_age</varname>减去<varname>vacuum_freeze_min_age</varname>事务就会在该表上调用一次自动清理。对那些为了空间回收目的而被正常清理的表，这是无关紧要的。然而，对静态表（包括接收插入但没有更新或删除的表）就没有为空间回收而清理的需要，因此尝试在非常大的静态表上强制自动清理的间隔最大化会非常有用。显然我们可以通过增加<varname>autovacuum_freeze_max_age</varname>或减少<varname>vacuum_freeze_min_age</varname>来实现此目的。
   </para>
<!-- pgdoc-cn_end sig_en=c22c25bec0eaf0ea72d29ce1a28c25de -->

<!-- pgdoc-cn_start sig_en=8f6edf4f4b28fd6e889d30c94257cef0 sig_cn_org=None source=14.1 
   <para>
    The effective maximum for <varname>vacuum_freeze_table_age</varname> is 0.95 *
    <varname>autovacuum_freeze_max_age</varname>; a setting higher than that will be
    capped to the maximum. A value higher than
    <varname>autovacuum_freeze_max_age</varname> wouldn't make sense because an
    anti-wraparound autovacuum would be triggered at that point anyway, and
    the 0.95 multiplier leaves some breathing room to run a manual
    <command>VACUUM</command> before that happens.  As a rule of thumb,
    <command>vacuum_freeze_table_age</command> should be set to a value somewhat
    below <varname>autovacuum_freeze_max_age</varname>, leaving enough gap so that
    a regularly scheduled <command>VACUUM</command> or an autovacuum triggered by
    normal delete and update activity is run in that window.  Setting it too
    close could lead to anti-wraparound autovacuums, even though the table
    was recently vacuumed to reclaim space, whereas lower values lead to more
    frequent aggressive vacuuming.
   </para>
________________________________________________________-->
   <para>
    <varname>vacuum_freeze_table_age</varname>的实际最大值是 0.95 * <varname>autovacuum_freeze_max_age</varname>，高于它的设置将被上限到最大值。一个高于<varname>autovacuum_freeze_max_age</varname>的值没有意义，因为不管怎样在那个点上都会触发一次防回卷自动清理，并且 0.95 的乘数为在防回卷自动清理发生之前运行一次手动<command>VACUUM</command>留出了一些空间。作为一种经验法则，<command>vacuum_freeze_table_age</command>应当被设置成一个低于<varname>autovacuum_freeze_max_age</varname>的值，留出一个足够的空间让一次被正常调度的<command>VACUUM</command>或一次被正常删除和更新活动触发的自动清理可以在这个窗口中被运行。将它设置得太接近可能导致防回卷自动清理，即使该表最近因为回收空间的目的被清理过，而较低的值将导致更频繁的全表扫描。
   </para>
<!-- pgdoc-cn_end sig_en=8f6edf4f4b28fd6e889d30c94257cef0 -->

<!-- pgdoc-cn_start sig_en=b1896a48b17de98190d760e766215ff7 sig_cn_org=None source=14.1 
   <para>
    The sole disadvantage of increasing <varname>autovacuum_freeze_max_age</varname>
    (and <varname>vacuum_freeze_table_age</varname> along with it) is that
    the <filename>pg_xact</filename> and <filename>pg_commit_ts</filename>
    subdirectories of the database cluster will take more space, because it
    must store the commit status and (if <varname>track_commit_timestamp</varname> is
    enabled) timestamp of all transactions back to
    the <varname>autovacuum_freeze_max_age</varname> horizon.  The commit status uses
    two bits per transaction, so if
    <varname>autovacuum_freeze_max_age</varname> is set to its maximum allowed value
    of two billion, <filename>pg_xact</filename> can be expected to grow to about half
    a gigabyte and <filename>pg_commit_ts</filename> to about 20GB.  If this
    is trivial compared to your total database size,
    setting <varname>autovacuum_freeze_max_age</varname> to its maximum allowed value
    is recommended.  Otherwise, set it depending on what you are willing to
    allow for <filename>pg_xact</filename> and <filename>pg_commit_ts</filename> storage.
    (The default, 200 million transactions, translates to about 50MB
    of <filename>pg_xact</filename> storage and about 2GB of <filename>pg_commit_ts</filename>
    storage.)
   </para>
________________________________________________________-->
   <para>
    增加<varname>autovacuum_freeze_max_age</varname>（以及和它一起的<varname>vacuum_freeze_table_age</varname>）的唯一不足是数据库集簇的<filename>pg_xact</filename>和<filename>pg_commit_ts</filename>子目录将占据更多空间，因为它必须存储所有向后<varname>autovacuum_freeze_max_age</varname>范围内的所有事务的提交状态和（如果启用了<varname>track_commit_timestamp</varname>）时间戳。提交状态为每个事务使用两个二进制位，因此如果<varname>autovacuum_freeze_max_age</varname>被设置为它的最大允许值 20 亿，<filename>pg_xact</filename>将会增长到大约 0.5 吉字节，<filename>pg_commit_ts</filename>大约20GB。如果这对于你的总数据库尺寸是微小的，我们推荐设置<varname>autovacuum_freeze_max_age</varname>为它的最大允许值。否则，基于你想要允许<filename>pg_xact</filename>和<filename>pg_commit_ts</filename>使用的存储空间大小来设置它（默认情况下 2 亿个事务大约等于<filename>pg_xact</filename>的 50 MB存储空间，<filename>pg_commit_ts</filename>的2GB的存储空间）。
   </para>
<!-- pgdoc-cn_end sig_en=b1896a48b17de98190d760e766215ff7 -->

<!-- pgdoc-cn_start sig_en=dd4cfe5204b8abfb77aab2b455800072 sig_cn_org=None source=14.1 
   <para>
    One disadvantage of decreasing <varname>vacuum_freeze_min_age</varname> is that
    it might cause <command>VACUUM</command> to do useless work: freezing a row
    version is a waste of time if the row is modified
    soon thereafter (causing it to acquire a new XID).  So the setting should
    be large enough that rows are not frozen until they are unlikely to change
    any more.
   </para>
________________________________________________________-->
   <para>
    减小<varname>vacuum_freeze_min_age</varname>的一个不足之处是它可能导致<command>VACUUM</command>做无用的工作：如果该行在被替换成<literal>FrozenXID</literal>之后很快就被修改（导致该行获得一个新的 XID），那么冻结一个行版本就是浪费时间。因此该设置应该足够大，这样直到行不再可能被修改之前，它们都不会被冻结。
   </para>
<!-- pgdoc-cn_end sig_en=dd4cfe5204b8abfb77aab2b455800072 -->

<!-- pgdoc-cn_start sig_en=4ee041bed2650a0c9947dec2ebe39a62 sig_cn_org=e7e7c8bfb36a9b335ddeeebe677ead92 source=15.7 
   <para>
    To track the age of the oldest unfrozen XIDs in a database,
    <command>VACUUM</command> stores XID
    statistics in the system tables <structname>pg_class</structname> and
    <structname>pg_database</structname>.  In particular,
    the <structfield>relfrozenxid</structfield> column of a table's
    <structname>pg_class</structname> row contains the oldest remaining unfrozen
    XID at the end of the most recent <command>VACUUM</command> that successfully
    advanced <structfield>relfrozenxid</structfield> (typically the most recent
    aggressive VACUUM).  Similarly, the
    <structfield>datfrozenxid</structfield> column of a database's
    <structname>pg_database</structname> row is a lower bound on the unfrozen XIDs
    appearing in that database &mdash; it is just the minimum of the
    per-table <structfield>relfrozenxid</structfield> values within the database.
    A convenient way to
    examine this information is to execute queries such as:

<programlisting>
SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;
</programlisting>

    The <literal>age</literal> column measures the number of transactions from the
    cutoff XID to the current transaction's XID.
   </para>
________________________________________________________-->
   <para>
    要跟踪数据库中最老的未冻结XID的年龄，<command>VACUUM</command>将XID统计信息存储在系统表
    <structname>pg_class</structname>和<structname>pg_database</structname>中。特别地，
    表的<structname>pg_class</structname>行的<structfield>relfrozenxid</structfield>列包含
    在最近一次成功推进<structfield>relfrozenxid</structfield>（通常是最近的主动VACUUM）结束时
    的最老未冻结XID。同样，数据库的<structname>pg_database</structname>行的
    <structfield>datfrozenxid</structfield>列是该数据库中出现的未冻结XIDs的下界 —— 它只是
    数据库中每个表的<structfield>relfrozenxid</structfield>值的最小值。查看这些信息的一种方便
    的方法是执行如下查询：

<programlisting>
SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;
</programlisting>

    <literal>age</literal>列测量从截止XID到当前事务XID的事务数量。
   </para>
<!-- pgdoc-cn_end sig_en=4ee041bed2650a0c9947dec2ebe39a62 -->

   <tip>
<!-- pgdoc-cn_start sig_en=2027003ed6e77b9f89367e35dcdb1b78 sig_cn_org=8ee87b5d23540d01f40652d653408f51 source=15.7 
    <para>
     When the <command>VACUUM</command> command's <literal>VERBOSE</literal>
     parameter is specified, <command>VACUUM</command> prints various
     statistics about the table.  This includes information about how
     <structfield>relfrozenxid</structfield> and
     <structfield>relminmxid</structfield> advanced.  The same details appear
     in the server log when autovacuum logging (controlled by <xref
      linkend="guc-log-autovacuum-min-duration"/>) reports on a
     <command>VACUUM</command> operation executed by autovacuum.
    </para>
________________________________________________________-->
    <para>
     当指定<command>VACUUM</command>命令的<literal>VERBOSE</literal>参数时，
     <command>VACUUM</command>会打印关于表的各种统计信息。这包括关于
     <structfield>relfrozenxid</structfield>和<structfield>relminmxid</structfield>
     如何增加的信息。当自动清理日志（由<xref linkend="guc-log-autovacuum-min-duration"/>
     控制）报告由自动清理执行的<command>VACUUM</command>操作时，相同的详细信息会出现在服务器日志中。
</para>
<!-- pgdoc-cn_end sig_en=2027003ed6e77b9f89367e35dcdb1b78 -->
   </tip>

<!-- pgdoc-cn_start sig_en=4204433d88fb17c6812e5a0f40ee83c6 sig_cn_org=1d2bd8e03b6da4148792aca58507fd8b source=15.7 
   <para>
    <command>VACUUM</command> normally only scans pages that have been modified
    since the last vacuum, but <structfield>relfrozenxid</structfield> can only be
    advanced when every page of the table
    that might contain unfrozen XIDs is scanned.  This happens when
    <structfield>relfrozenxid</structfield> is more than
    <varname>vacuum_freeze_table_age</varname> transactions old, when
    <command>VACUUM</command>'s <literal>FREEZE</literal> option is used, or when all
    pages that are not already all-frozen happen to
    require vacuuming to remove dead row versions. When <command>VACUUM</command>
    scans every page in the table that is not already all-frozen, it should
    set <literal>age(relfrozenxid)</literal> to a value just a little more than the
    <varname>vacuum_freeze_min_age</varname> setting
    that was used (more by the number of transactions started since the
    <command>VACUUM</command> started).  <command>VACUUM</command>
    will set <structfield>relfrozenxid</structfield> to the oldest XID
    that remains in the table, so it's possible that the final value
    will be much more recent than strictly required.
    If no <structfield>relfrozenxid</structfield>-advancing
    <command>VACUUM</command> is issued on the table until
    <varname>autovacuum_freeze_max_age</varname> is reached, an autovacuum will soon
    be forced for the table.
   </para>
________________________________________________________-->
   <para>
    <command>VACUUM</command>通常只扫描自上次清理以来已经修改的页面，但<structfield>relfrozenxid</structfield>只能在扫描可能包含未冻结XID的表的每个页面时才能推进。
    当<structfield>relfrozenxid</structfield>超过<varname>vacuum_freeze_table_age</varname>个事务时，当使用<command>VACUUM</command>的<literal>FREEZE</literal>选项时，或者当所有未全部冻结的页面碰巧需要进行清理以删除死行版本时，会发生这种情况。
    当<command>VACUUM</command>扫描表中尚未全部冻结的每个页面时，应将<literal>age(relfrozenxid)</literal>设置为比使用的<varname>vacuum_freeze_min_age</varname>设置稍高一点的值（再加上自<command>VACUUM</command>开始以来启动的事务数）。
    <command>VACUUM</command>将<structfield>relfrozenxid</structfield>设置为表中仍存在的最旧XID，因此最终值可能比严格要求的要新得多。
    如果在达到<varname>autovacuum_freeze_max_age</varname>之前没有对表发出推进<structfield>relfrozenxid</structfield>的<command>VACUUM</command>，则很快将为该表强制执行自动清理。
</para>
<!-- pgdoc-cn_end sig_en=4204433d88fb17c6812e5a0f40ee83c6 -->

<!-- pgdoc-cn_start sig_en=9837f48fd2eb5d2a7d4528b92603bb74 sig_cn_org=def678abadf5b187b43777928423a5e3 source=15.7 
   <para>
    If for some reason autovacuum fails to clear old XIDs from a table, the
    system will begin to emit warning messages like this when the database's
    oldest XIDs reach forty million transactions from the wraparound point:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 39985967 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in that database.
</programlisting>

    (A manual <command>VACUUM</command> should fix the problem, as suggested by the
    hint; but note that the <command>VACUUM</command> should be performed by a
    superuser, else it will fail to process system catalogs, which prevent it from
    being able to advance the database's <structfield>datfrozenxid</structfield>.)
    If these warnings are ignored, the system will refuse to assign new XIDs once
    there are fewer than three million transactions left until wraparound:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.
</programlisting>

    In this condition any transactions already in progress can continue,
    but only read-only transactions can be started. Operations that
    modify database records or truncate relations will fail.
    The <command>VACUUM</command> command can still be run normally.
    Contrary to what the hint states, it is not necessary or desirable to stop the
    postmaster or enter single user-mode in order to restore normal operation.
    Instead, follow these steps:

    <orderedlist>
     <listitem>
      <simpara>Resolve old prepared transactions. You can find these by checking
       <link linkend="view-pg-prepared-xacts">pg_prepared_xacts</link> for rows where
       <literal>age(transactionid)</literal> is large. Such transactions should be
       committed or rolled back.</simpara>
     </listitem>
     <listitem>
      <simpara>End long-running open transactions. You can find these by checking
       <link linkend="monitoring-pg-stat-activity-view">pg_stat_activity</link> for rows where
       <literal>age(backend_xid)</literal> or <literal>age(backend_xmin)</literal> is
       large. Such transactions should be committed or rolled back, or the session
       can be terminated using <literal>pg_terminate_backend</literal>.</simpara>
     </listitem>
     <listitem>
      <simpara>Drop any old replication slots. Use
       <link linkend="monitoring-pg-stat-replication-view">pg_stat_replication</link> to
       find slots where <literal>age(xmin)</literal> or <literal>age(catalog_xmin)</literal>
       is large. In many cases, such slots were created for replication to servers that no
       longer exist, or that have been down for a long time. If you drop a slot for a server
       that still exists and might still try to connect to that slot, that replica may
       need to be rebuilt.</simpara>
     </listitem>
     <listitem>
      <simpara>Execute <command>VACUUM</command> in the target database. A database-wide
       <literal>VACUUM</literal> is simplest; to reduce the time required, it as also possible
       to issue manual <command>VACUUM</command> commands on the tables where
       <structfield>relminxid</structfield> is oldest. Do not use <literal>VACUUM FULL</literal>
       in this scenario, because it requires an XID and will therefore fail, except in super-user
       mode, where it will instead consume an XID and thus increase the risk of transaction ID
       wraparound. Do not use <literal>VACUUM FREEZE</literal> either, because it will do
       more than the minimum amount of work required to restore normal operation.</simpara>
     </listitem>
     <listitem>
      <simpara>Once normal operation is restored, ensure that autovacuum is properly configured
       in the target database in order to avoid future problems.</simpara>
     </listitem>
    </orderedlist>
   </para>
________________________________________________________-->
   <para>
    如果由于某种原因，自动清理程序未能清除表中的旧XID，当数据库的最旧XID达到距离回绕点四千万次事务时，系统将开始发出如下警告消息：

<programlisting>
WARNING:  database "mydb" must be vacuumed within 39985967 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in that database.
</programlisting>

    （如提示所建议，手动执行<command>VACUUM</command>应该可以解决问题；但请注意，<command>VACUUM</command>应该由超级用户执行，否则将无法处理系统目录，从而无法推进数据库的<structfield>datfrozenxid</structfield>。）
    如果忽略这些警告，系统将在距离回绕点不足三百万次事务时拒绝分配新的XID：

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.
</programlisting>

    在这种情况下，已经在进行的任何事务可以继续，但只能启动只读事务。修改数据库记录或截断关系的操作将失败。
    <command>VACUUM</command>命令仍然可以正常运行。
    与提示所述相反，为了恢复正常操作，无需停止postmaster或进入单用户模式。
    取而代之，请按照以下步骤操作：

    <orderedlist>
     <listitem>
      <simpara>解决旧的预备事务。您可以通过<link linkend="view-pg-prepared-xacts">pg_prepared_xacts</link>
	  检查<literal>age(transactionid)</literal>较大的行来查找这些事务，可以在其中找到这些事务，这些事务应该被提交或回滚。</simpara>
     </listitem>
     <listitem>
      <simpara>结束长时间运行的开放事务。您可以通过<link linkend="monitoring-pg-stat-activity-view">pg_stat_activity</link>
	  检查<literal>age(backend_xid)</literal>或<literal>age(backend_xmin)</literal>较大的行来查找这些事务，这些事务应该被提交或回滚，
	  或者可以使用<literal>pg_terminate_backend</literal>终止会话。</simpara>
     </listitem>
     <listitem>
      <simpara>删除任何旧的复制插槽。使用<link linkend="monitoring-pg-stat-replication-view">pg_stat_replication</link>检查<literal>age(xmin)</literal>或<literal>age(catalog_xmin)</literal>较大的插槽，可以找到这些插槽。在许多情况下，这些插槽是为了复制到已不存在或长时间关闭的服务器而创建的。如果删除了仍然存在并可能尝试连接到该插槽的服务器的插槽，则可能需要重建该副本。</simpara>
     </listitem>
     <listitem>
      <simpara>在目标数据库中执行<command>VACUUM</command>。对整个数据库执行<literal>VACUUM</literal>是最简单的方法；为了减少所需的时间，也可以在<structfield>relminxid</structfield>最老的表上发出手动<command>VACUUM</command>命令。在这种情况下不要使用<literal>VACUUM FULL</literal>，因为它需要一个XID，因此会失败，除非在超级用户模式下，在那里它将消耗一个XID，从而增加事务ID回绕的风险。也不要使用<literal>VACUUM FREEZE</literal>，因为它将执行比恢复正常操作所需的最小工作量更多的工作。</simpara>
     </listitem>
     <listitem>
      <simpara>一旦恢复正常操作，请确保在目标数据库中正确配置自动清理程序，以避免未来出现问题。</simpara>
     </listitem>
    </orderedlist>
   </para>
<!-- pgdoc-cn_end sig_en=9837f48fd2eb5d2a7d4528b92603bb74 -->

   <note>
<!-- pgdoc-cn_start sig_en=b0dddf0a20938d7315fe6db2b580d820 sig_cn_org=b2afe1c7385912f2774289b17a7a41ee source=15.7 
    <para>
     In earlier versions, it was sometimes necessary to stop the postmaster and
     <command>VACUUM</command> the database in a single-user mode. In typical scenarios, this
     is no longer necessary, and should be avoided whenever possible, since it involves taking
     the system down. It is also riskier, since it disables transaction ID wraparound safeguards
     that are designed to prevent data loss.  The only reason to use single-user mode in this
     scenario is if you wish to <command>TRUNCATE</command> or <command>DROP</command> unneeded
     tables to avoid needing to <command>VACUUM</command> them.  The three-million-transaction
     safety margin exists to let the administrator do this. See the
     <xref linkend="app-postgres"/> reference page for details about using single-user mode.
    </para>
________________________________________________________-->
    <para>
     在早期版本中，有时需要停止postmaster并以单用户模式<command>VACUUM</command>数据库。
     在典型情况下，这不再是必要的，应尽量避免，因为这会导致系统停机。
     这也更加危险，因为它会禁用旨在防止数据丢失的事务ID环绕保护措施。
     在这种情况下使用单用户模式的唯一原因是，如果您希望<command>TRUNCATE</command>或<command>DROP</command>不需要的表以避免需要<command>VACUUM</command>它们。
     三百万事务的安全边界存在是为了让管理员执行此操作。有关使用单用户模式的详细信息，请参阅<xref linkend="app-postgres"/>参考页面。
</para>
<!-- pgdoc-cn_end sig_en=b0dddf0a20938d7315fe6db2b580d820 -->
   </note>

   <sect3 id="vacuum-for-multixact-wraparound">
<!-- pgdoc-cn_start sig_en=b8a780a944c81f247fafd2416ffcff6a sig_cn_org=None source=14.1 
    <title>Multixacts and Wraparound</title>
________________________________________________________-->
    <title>多事务和回卷</title>
<!-- pgdoc-cn_end sig_en=b8a780a944c81f247fafd2416ffcff6a -->

<!-- pgdoc-cn_start sig_en=d8fbed2929da59fa2992f963754a7e44 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>MultiXactId</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>MultiXactId</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d8fbed2929da59fa2992f963754a7e44 -->

<!-- pgdoc-cn_start sig_en=7e02145570082e236cd1189150239bb1 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>wraparound</primary>
     <secondary>of multixact IDs</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>wraparound</primary>
     <secondary>of multixact IDs</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=7e02145570082e236cd1189150239bb1 -->

<!-- pgdoc-cn_start sig_en=beab04952d8c2d12fbf6eda745685439 sig_cn_org=None source=14.1 
    <para>
     <firstterm>Multixact IDs</firstterm> are used to support row locking by
     multiple transactions.  Since there is only limited space in a tuple
     header to store lock information, that information is encoded as
     a <quote>multiple transaction ID</quote>, or multixact ID for short,
     whenever there is more than one transaction concurrently locking a
     row.  Information about which transaction IDs are included in any
     particular multixact ID is stored separately in
     the <filename>pg_multixact</filename> subdirectory, and only the multixact ID
     appears in the <structfield>xmax</structfield> field in the tuple header.
     Like transaction IDs, multixact IDs are implemented as a
     32-bit counter and corresponding storage, all of which requires
     careful aging management, storage cleanup, and wraparound handling.
     There is a separate storage area which holds the list of members in
     each multixact, which also uses a 32-bit counter and which must also
     be managed.
    </para>
________________________________________________________-->
    <para>
     <firstterm>Multixact ID</firstterm>被用来支持被多个事务锁定的行。由于在一个元组头部
     只有有限的空间可以用来存储锁信息，所以只要有多于一个事务并发地锁住一个行，
     锁信息将使用一个<quote>多个事务 ID</quote>（或简称多事务 ID）来编码。任何特定
     多事务 ID 中包括的事务 ID 的信息被独立地存储在<filename>pg_multixact</filename>子目
     录中，并且只有多事务 ID 出现在元组头部的<structfield>xmax</structfield>域中。和事务 ID 
     类似，多事务 ID 也是用一个 32 位计数器实现，并且也采用了相似的存储，这些都要
     求仔细的年龄管理、存储清除和回卷处理。在每个多事务中都有一个独立的存储区域
     保存成员列表，它也使用一个 32 位计数器并且也应被管理。
    </para>
<!-- pgdoc-cn_end sig_en=beab04952d8c2d12fbf6eda745685439 -->

<!-- pgdoc-cn_start sig_en=53ebcb23235f4ce5a663df535ccf77e2 sig_cn_org=None source=14.1 
    <para>
     Whenever <command>VACUUM</command> scans any part of a table, it will replace
     any multixact ID it encounters which is older than
     <xref linkend="guc-vacuum-multixact-freeze-min-age"/>
     by a different value, which can be the zero value, a single
     transaction ID, or a newer multixact ID.  For each table,
     <structname>pg_class</structname>.<structfield>relminmxid</structfield> stores the oldest
     possible multixact ID still appearing in any tuple of that table.
     If this value is older than
     <xref linkend="guc-vacuum-multixact-freeze-table-age"/>, an aggressive
     vacuum is forced.  As discussed in the previous section, an aggressive
     vacuum means that only those pages which are known to be all-frozen will
     be skipped.  <function>mxid_age()</function> can be used on
     <structname>pg_class</structname>.<structfield>relminmxid</structfield> to find its age.
    </para>
________________________________________________________-->
    <para>
     在一次<command>VACUUM</command>表扫描（部分或者全部）期间，任何比
     <xref linkend="guc-vacuum-multixact-freeze-min-age"/>
     要老的多事务 ID 会被替换为一个不同的值，该值可以是零值、
     一个单一事务 ID 或者一个更新的多事务 ID。
     对于每一个表，<structname>pg_class</structname>.<structfield>relminmxid</structfield>
     存储了在该表任意元组中仍然存在的最老可能多事务 ID。如果这个值比
     <xref linkend="guc-vacuum-multixact-freeze-table-age"/>老，
     将强制一次全表扫描。可以在
     <structname>pg_class</structname>.<structfield>relminmxid</structfield>
     上使用<function>mxid_age()</function>来找到它的年龄。
    </para>
<!-- pgdoc-cn_end sig_en=53ebcb23235f4ce5a663df535ccf77e2 -->

<!-- pgdoc-cn_start sig_en=c3897e9bd8023fe9b72fcd9989008c05 sig_cn_org=ed34290001d13c6638508159e6cde44a source=15.7 
    <para>
     Aggressive <command>VACUUM</command>s, regardless of what causes
     them, are <emphasis>guaranteed</emphasis> to be able to advance
     the table's <structfield>relminmxid</structfield>.
     Eventually, as all tables in all databases are scanned and their
     oldest multixact values are advanced, on-disk storage for older
     multixacts can be removed.
    </para>
________________________________________________________-->
    <para>
     无论是什么原因导致的激进的<command>VACUUM</command>，都<emphasis>保证</emphasis>能够推进表的<structfield>relminmxid</structfield>。
     最终，当所有数据库中的所有表都被扫描并且它们最老的多重事务值被推进时，旧的多重事务的磁盘存储可以被移除。
</para>
<!-- pgdoc-cn_end sig_en=c3897e9bd8023fe9b72fcd9989008c05 -->

<!-- pgdoc-cn_start sig_en=775d1e01b9237ad456d0f5543af0ddc1 sig_cn_org=748376b61d3bf7a3708df1801e7b3c47 source=15.7 
    <para>
     As a safety device, an aggressive vacuum scan will
     occur for any table whose multixact-age is greater than <xref
     linkend="guc-autovacuum-multixact-freeze-max-age"/>.  Also, if the
     storage occupied by multixacts members exceeds 2GB, aggressive vacuum
     scans will occur more often for all tables, starting with those that
     have the oldest multixact-age.  Both of these kinds of aggressive
     scans will occur even if autovacuum is nominally disabled.
    </para>
________________________________________________________-->
    <para>
     作为一种安全设备，对于任何多事务ID的年龄大于<xref linkend="guc-autovacuum-multixact-freeze-max-age"/>的表，
     将进行积极的真空扫描。此外，如果多事务ID成员占用的存储空间超过2GB，
     则对所有表更频繁地进行积极的真空扫描，从具有最老的多事务ID年龄的表开始。
     即使自动真空名义上被禁用，这两种类型的积极扫描也会发生。
</para>
<!-- pgdoc-cn_end sig_en=775d1e01b9237ad456d0f5543af0ddc1 -->

<!-- pgdoc-cn_start sig_en=498b336343e17d972c35595f4b3469ac sig_cn_org=528fa7792e1f1586f0dd4bcc167ded68 source=15.7 
    <para>
     Similar to the XID case, if autovacuum fails to clear old MXIDs from a table, the
     system will begin to emit warning messages when the database's oldest MXIDs reach forty
     million transactions from the wraparound point.  And, just as an the XID case, if these
     warnings are ignored, the system will refuse to generate new MXIDs once there are fewer
     than three million left until wraparound.
    </para>
________________________________________________________-->
    <para>
     与XID案例类似，如果自动清理程序无法清除表中的旧MXID，当数据库的最旧MXID达到距离
     回绕点四千万个事务时，系统将开始发出警告消息。而且，就像XID案例一样，如果忽略
     这些警告，一旦距离回绕点不足三百万个事务，系统将拒绝生成新的MXID。
    </para>
<!-- pgdoc-cn_end sig_en=498b336343e17d972c35595f4b3469ac -->

<!-- pgdoc-cn_start sig_en=cdc1ce36c4d6420ae8973a1ba5964c98 sig_cn_org=172b6f0b5a63169a4d915417aa708430 source=15.7 
    <para>
     Normal operation when MXIDs are exhausted can be restored in much the same way as
     when XIDs are exhausted. Follow the same steps in the previous section, but with the
     following differences:

    <orderedlist>
     <listitem>
      <simpara>Running transactions and prepared transactions can be ignored if there
       is no chance that they might appear in a multixact.</simpara>
     </listitem>
     <listitem>
      <simpara>MXID information is not directly visible in system views such as
       <literal>pg_stat_activity</literal>; however, looking for old XIDs is still a good
       way of determining which transactions are causing MXID wraparound problems.</simpara>
     </listitem>
     <listitem>
      <simpara>XID exhaustion will block all write transactions, but MXID exhaustion will
       only block a subset of write transactions, specifically those that involve
       row locks that require an MXID.</simpara>
     </listitem>
    </orderedlist>
   </para>
________________________________________________________-->
    <para>
     当MXIDs用尽时，可以通过与XIDs用尽时相同的方式恢复正常操作。按照前一节中的相同步骤进行，
     但有以下区别：

    <orderedlist>
     <listitem>
      <simpara>如果没有可能出现在多重事务中的事务和准备事务，则可以忽略运行事务和准备事务。</simpara>
     </listitem>
     <listitem>
      <simpara>MXID信息在诸如<literal>pg_stat_activity</literal>之类的系统视图中不直接可见；
       但是，查找旧的XIDs仍然是确定哪些事务导致MXID环绕问题的好方法。</simpara>
     </listitem>
     <listitem>
      <simpara>XID用尽将阻止所有写事务，但MXID用尽只会阻止一部分写事务，具体来说，那些涉及
       需要MXID的行锁的写事务。</simpara>
     </listitem>
    </orderedlist>
   </para>
<!-- pgdoc-cn_end sig_en=cdc1ce36c4d6420ae8973a1ba5964c98 -->

   </sect3>
  </sect2>

  <sect2 id="autovacuum">
<!-- pgdoc-cn_start sig_en=668d55eb86ad34733213248c36dbe679 sig_cn_org=None source=14.1 
   <title>The Autovacuum Daemon</title>
________________________________________________________-->
   <title>自动清理后台进程</title>
<!-- pgdoc-cn_end sig_en=668d55eb86ad34733213248c36dbe679 -->

<!-- pgdoc-cn_start sig_en=d21658f216a1cc1a3f2ce972de7e9110 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>autovacuum</primary>
    <secondary>general information</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>自动清理</primary>
    <secondary>一般信息</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d21658f216a1cc1a3f2ce972de7e9110 -->
<!-- pgdoc-cn_start sig_en=b6a425f3f6a26909851bf8948b58f5a8 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> has an optional but highly
    recommended feature called <firstterm>autovacuum</firstterm>,
    whose purpose is to automate the execution of
    <command>VACUUM</command> and <command>ANALYZE</command> commands.
    When enabled, autovacuum checks for
    tables that have had a large number of inserted, updated or deleted
    tuples.  These checks use the statistics collection facility;
    therefore, autovacuum cannot be used unless <xref
    linkend="guc-track-counts"/> is set to <literal>true</literal>.
    In the default configuration, autovacuuming is enabled and the related
    configuration parameters are appropriately set.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>有一个可选的但是被高度推荐的特性<firstterm>autovacuum</firstterm>，它的目的是自动执行<command>VACUUM</command>和<command>ANALYZE</command>命令。当它被启用时，自动清理会检查被大量插入、更新或删除元组的表。这些检查会利用统计信息收集功能，因此除非<xref linkend="guc-track-counts"/>被设置为<literal>true</literal>，自动清理不能被使用。在默认配置下，自动清理是被启用的并且相关配置参数已被正确配置。
   </para>
<!-- pgdoc-cn_end sig_en=b6a425f3f6a26909851bf8948b58f5a8 -->

<!-- pgdoc-cn_start sig_en=6a0f7deab2cbba3d323a529518bc1424 sig_cn_org=None source=14.1 
   <para>
    The <quote>autovacuum daemon</quote> actually consists of multiple processes.
    There is a persistent daemon process, called the
    <firstterm>autovacuum launcher</firstterm>, which is in charge of starting
    <firstterm>autovacuum worker</firstterm> processes for all databases. The
    launcher will distribute the work across time, attempting to start one
    worker within each database every <xref linkend="guc-autovacuum-naptime"/>
    seconds.  (Therefore, if the installation has <replaceable>N</replaceable> databases,
    a new worker will be launched every
    <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable> seconds.)
    A maximum of <xref linkend="guc-autovacuum-max-workers"/> worker processes
    are allowed to run at the same time. If there are more than
    <varname>autovacuum_max_workers</varname> databases to be processed,
    the next database will be processed as soon as the first worker finishes.
    Each worker process will check each table within its database and
    execute <command>VACUUM</command> and/or <command>ANALYZE</command> as needed.
    <xref linkend="guc-log-autovacuum-min-duration"/> can be set to monitor
    autovacuum workers' activity.
   </para>
________________________________________________________-->
   <para>
    <quote>自动清理后台进程</quote>实际上由多个进程组成。有一个称为
    <firstterm>自动清理启动器</firstterm>的常驻后台进程，
    它负责为所有数据库启动<firstterm>自动清理工作者</firstterm>进程。
    启动器将把工作散布在一段时间上，它每隔
    <xref linkend="guc-autovacuum-naptime"/>秒尝试在每个数据库中启动一个工作者
    （因此，如果安装中有<replaceable>N</replaceable>个数据库，则每
    <varname>autovacuum_naptime</varname>/<replaceable>N</replaceable>秒将启动一个新的工作者）。
    在同一时间只允许最多<xref linkend="guc-autovacuum-max-workers"/>
    个工作者进程运行。如果有超过<varname>autovacuum_max_workers</varname>
    个数据库需要被处理，下一个数据库将在第一个工作者结束后马上被处理。
    每一个工作者进程将检查其数据库中的每一个表并且在需要时执行
    <command>VACUUM</command>和/或<command>ANALYZE</command>。
    可以设置<xref linkend="guc-log-autovacuum-min-duration"/>
    来监控自动清理工作者的活动。
   </para>
<!-- pgdoc-cn_end sig_en=6a0f7deab2cbba3d323a529518bc1424 -->

<!-- pgdoc-cn_start sig_en=033f82ea6d85b8fe2f6bd30ec329129e sig_cn_org=None source=14.1 
   <para>
    If several large tables all become eligible for vacuuming in a short
    amount of time, all autovacuum workers might become occupied with
    vacuuming those tables for a long period.  This would result
    in other tables and databases not being vacuumed until a worker becomes
    available. There is no limit on how many workers might be in a
    single database, but workers do try to avoid repeating work that has
    already been done by other workers. Note that the number of running
    workers does not count towards <xref linkend="guc-max-connections"/> or
    <xref linkend="guc-superuser-reserved-connections"/> limits.
   </para>
________________________________________________________-->
   <para>
    如果在一小段时间内多个大型表都变得可以被清理，所有的自动清理工作者可能都会被占用来在一段长的时间内清理这些表。这将会造成其他的表和数据库无法被清理，直到一个工作者变得可用。对于一个数据库中的工作者数量并没有限制，但是工作者确实会试图避免重复已经被其他工作者完成的工作。注意运行着的工作者的数量不会被计入<xref linkend="guc-max-connections"/>或<xref linkend="guc-superuser-reserved-connections"/>限制。
   </para>
<!-- pgdoc-cn_end sig_en=033f82ea6d85b8fe2f6bd30ec329129e -->

<!-- pgdoc-cn_start sig_en=bd39032eaac700602b4258da26decece sig_cn_org=None source=14.1 
   <para>
    Tables whose <structfield>relfrozenxid</structfield> value is more than
    <xref linkend="guc-autovacuum-freeze-max-age"/> transactions old are always
    vacuumed (this also applies to those tables whose freeze max age has
    been modified via storage parameters; see below).  Otherwise, if the
    number of tuples obsoleted since the last
    <command>VACUUM</command> exceeds the <quote>vacuum threshold</quote>, the
    table is vacuumed.  The vacuum threshold is defined as:
<programlisting>
vacuum threshold = vacuum base threshold + vacuum scale factor * number of tuples
</programlisting>
    where the vacuum base threshold is
    <xref linkend="guc-autovacuum-vacuum-threshold"/>,
    the vacuum scale factor is
    <xref linkend="guc-autovacuum-vacuum-scale-factor"/>,
    and the number of tuples is
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
   </para>
________________________________________________________-->
   <para>
    <structfield>relfrozenxid</structfield>值比<xref linkend="guc-autovacuum-freeze-max-age"/>事务年龄更大的表总是会被清理（这页表示这些表的冻结最大年龄被通过表的存储参数修改过，参见后文）。否则，如果从上次<command>VACUUM</command>以来失效的元组数超过<quote>清理阈值</quote>，表也会被清理。清理阈值定义为：
<programlisting>
清理阈值 = 清理基本阈值 + 清理缩放系数 * 元组数
</programlisting>
    其中清理基本阈值为<xref linkend="guc-autovacuum-vacuum-threshold"/>，
    清理缩放系数为<xref linkend="guc-autovacuum-vacuum-scale-factor"/>，
    元组数为<structname>pg_class</structname>.<structfield>reltuples</structfield>。
   </para>
<!-- pgdoc-cn_end sig_en=bd39032eaac700602b4258da26decece -->

<!-- pgdoc-cn_start sig_en=22aa398434163749cec31d3c53f8fe5f sig_cn_org=043286d1905d3af05a6067518e641c6e source=15.7 
   <para>
    The table is also vacuumed if the number of tuples inserted since the last
    vacuum has exceeded the defined insert threshold, which is defined as:
<programlisting>
vacuum insert threshold = vacuum base insert threshold + vacuum insert scale factor * number of tuples
</programlisting>
    where the vacuum insert base threshold is
    <xref linkend="guc-autovacuum-vacuum-insert-threshold"/>,
    and vacuum insert scale factor is
    <xref linkend="guc-autovacuum-vacuum-insert-scale-factor"/>.
    Such vacuums may allow portions of the table to be marked as
    <firstterm>all visible</firstterm> and also allow tuples to be frozen, which
    can reduce the work required in subsequent vacuums.
    For tables which receive <command>INSERT</command> operations but no or
    almost no <command>UPDATE</command>/<command>DELETE</command> operations,
    it may be beneficial to lower the table's
    <xref linkend="reloption-autovacuum-freeze-min-age"/> as this may allow
    tuples to be frozen by earlier vacuums.  The number of obsolete tuples and
    the number of inserted tuples are obtained from the cumulative statistics system;
    it is a semi-accurate count updated by each <command>UPDATE</command>,
    <command>DELETE</command> and <command>INSERT</command> operation.  (It is
    only semi-accurate because some information might be lost under heavy
    load.)  If the <structfield>relfrozenxid</structfield> value of the table
    is more than <varname>vacuum_freeze_table_age</varname> transactions old,
    an aggressive vacuum is performed to freeze old tuples and advance
    <structfield>relfrozenxid</structfield>; otherwise, only pages that have been modified
    since the last vacuum are scanned.
   </para>
________________________________________________________-->
   <para>
    如果自上次清理以来插入的元组数量超过定义的插入阈值，则还会对表进行清理，该阈值定义为：
<programlisting>
清理插入阈值 = 清理基本插入阈值 + 清理插入比例因子 * 元组数量
</programlisting>
    其中清理插入基本阈值是
    <xref linkend="guc-autovacuum-vacuum-insert-threshold"/>,
    而清理插入比例因子是
    <xref linkend="guc-autovacuum-vacuum-insert-scale-factor"/>.
    这样的清理可能会将表的部分标记为
    <firstterm>全部可见</firstterm>，并且还可以冻结元组，这样可以减少后续清理所需的工作量。
    对于接收<command>INSERT</command>操作但几乎没有或几乎没有<command>UPDATE</command>/<command>DELETE</command>操作的表，
    降低表的
    <xref linkend="reloption-autovacuum-freeze-min-age"/>可能是有益的，因为这可能允许早期的清理冻结元组。
    废弃元组的数量和插入元组的数量是从累积统计系统中获取的；
    这是一个由每个<command>UPDATE</command>、<command>DELETE</command>和<command>INSERT</command>操作更新的半准确计数。
    （它只是半准确的，因为在重载下可能会丢失一些信息。）
    如果表的<structfield>relfrozenxid</structfield>值比<varname>vacuum_freeze_table_age</varname>个事务更旧，
    则执行积极的清理以冻结旧元组并推进
    <structfield>relfrozenxid</structfield>；否则，只扫描自上次清理以来已修改的页面。
   </para>
<!-- pgdoc-cn_end sig_en=22aa398434163749cec31d3c53f8fe5f -->

<!-- pgdoc-cn_start sig_en=6272cbec47b3fac36a85b2fe196fe89a sig_cn_org=None source=14.1 
   <para>
    For analyze, a similar condition is used: the threshold, defined as:
<programlisting>
analyze threshold = analyze base threshold + analyze scale factor * number of tuples
</programlisting>
    is compared to the total number of tuples inserted, updated, or deleted
    since the last <command>ANALYZE</command>.
   </para>
________________________________________________________-->
   <para>
    对于分析，也使用了一个相似的阈值：
<programlisting>
分析阈值 = 分析基本阈值 + 分析缩放系数 * 元组数
</programlisting>
    该阈值将与自从上次<command>ANALYZE</command>以来被插入、更新或删除的元组数进行比较。
   </para>
<!-- pgdoc-cn_end sig_en=6272cbec47b3fac36a85b2fe196fe89a -->

<!-- pgdoc-cn_start sig_en=fe068988ae5478ee537407f0b05a0d6d sig_cn_org=d4070111d8ed930193cc19db9dc49699 source=15.7 
   <para>
    Partitioned tables do not directly store tuples and consequently
    are not processed by autovacuum.  (Autovacuum does process table
    partitions just like other tables.)  Unfortunately, this means that
    autovacuum does  not run <command>ANALYZE</command> on partitioned
    tables, and this can cause suboptimal plans for queries that reference
    partitioned table statistics.  You can work around this problem by
    manually running <command>ANALYZE</command> on partitioned tables
    when they are first populated, and again whenever the distribution
    of data in their partitions changes significantly.
   </para>
________________________________________________________-->
   <para>
    分区表不直接存储元组，因此不会被自动清理处理。(自动清理会像处理其他表一样处理表分区。)不幸的是，这意味着自动清理不会在分区表上运行<command>ANALYZE</command>，这可能导致引用分区表统计信息的查询产生次优化的计划。当分区表首次填充时，您可以通过手动运行<command>ANALYZE</command>来解决这个问题，并在它们的分区数据分布发生显著变化时再次运行。
   </para>
<!-- pgdoc-cn_end sig_en=fe068988ae5478ee537407f0b05a0d6d -->

<!-- pgdoc-cn_start sig_en=5132cf1530cb35a595866bf8720c8cda sig_cn_org=None source=14.1 
   <para>
    Temporary tables cannot be accessed by autovacuum.  Therefore,
    appropriate vacuum and analyze operations should be performed via
    session SQL commands.
   </para>
________________________________________________________-->
   <para>
    临时表不能被自动清理访问。因此，临时表的清理和分析操作必须通过会话期间的SQL命令来执行。
   </para>
<!-- pgdoc-cn_end sig_en=5132cf1530cb35a595866bf8720c8cda -->

<!-- pgdoc-cn_start sig_en=db0e5911331da364d95336f1ca152037 sig_cn_org=None source=14.1 
   <para>
    The default thresholds and scale factors are taken from
    <filename>postgresql.conf</filename>, but it is possible to override them
    (and many other autovacuum control parameters) on a per-table basis; see
    <xref linkend="sql-createtable-storage-parameters"/> for more information.
    If a setting has been changed via a table's storage parameters, that value
    is used when processing that table; otherwise the global settings are
    used. See <xref linkend="runtime-config-autovacuum"/> for more details on
    the global settings.
   </para>
________________________________________________________-->
   <para>
    默认的阈值和缩放系数都取自于<filename>postgresql.conf</filename>，但是可以为每一个表重写它们(和许多其他自动清理控制参数)，
    详情参见<xref linkend="sql-createtable-storage-parameters"/>。
    如果一个设置已经通过一个表的存储参数修改，那么在处理该表时使用该值，否则使用全局设置。
    全局设置请参阅<xref linkend="runtime-config-autovacuum"/>。
   </para>
<!-- pgdoc-cn_end sig_en=db0e5911331da364d95336f1ca152037 -->

<!-- pgdoc-cn_start sig_en=93ab4bfddbe6a07b3ee6f4ed1e252429 sig_cn_org=None source=14.1 
   <para>
    When multiple workers are running, the autovacuum cost delay parameters
    (see <xref linkend="runtime-config-resource-vacuum-cost"/>) are
    <quote>balanced</quote> among all the running workers, so that the
    total I/O impact on the system is the same regardless of the number
    of workers actually running.  However, any workers processing tables whose
    per-table <literal>autovacuum_vacuum_cost_delay</literal> or
    <literal>autovacuum_vacuum_cost_limit</literal> storage parameters have been set
    are not considered in the balancing algorithm.
   </para>
________________________________________________________-->
   <para>
    当多个工作者运行时，在所有运行着的工作者之间自动清理代价延迟参数
    (参阅<xref linkend="runtime-config-resource-vacuum-cost"/>)是
    <quote>平衡的</quote>，这样不管实际运行的工作者数量是多少，
    对于系统的总体 I/O 影响总是相同的。不过，任何正在处理已经设置了每表
    <literal>autovacuum_vacuum_cost_delay</literal>或
    <literal>autovacuum_vacuum_cost_limit</literal>
    存储参数的表的工作者不会被考虑在均衡算法中。
   </para>
<!-- pgdoc-cn_end sig_en=93ab4bfddbe6a07b3ee6f4ed1e252429 -->

<!-- pgdoc-cn_start sig_en=71280232a804f5538f8217fa42597d00 sig_cn_org=None source=14.1 
   <para>
    Autovacuum workers generally don't block other commands.  If a process
    attempts to acquire a lock that conflicts with the
    <literal>SHARE UPDATE EXCLUSIVE</literal> lock held by autovacuum, lock
    acquisition will interrupt the autovacuum.  For conflicting lock modes,
    see <xref linkend="table-lock-compatibility"/>.  However, if the autovacuum
    is running to prevent transaction ID wraparound (i.e., the autovacuum query
    name in the <structname>pg_stat_activity</structname> view ends with
    <literal>(to prevent wraparound)</literal>), the autovacuum is not
    automatically interrupted.
   </para>
________________________________________________________-->
   <para>
    autovacuum工作进程通常不会阻止其他命令。如果某个进程尝试获取与autovacuum持有的<literal>SHARE UPDATE EXCLUSIVE</literal>锁冲突的锁，则锁获取将中断该autovacuum。有关冲突的锁定模式，请参见<xref linkend="table-lock-compatibility"/>。
    但是，如果autovacuum正在运行以防止事务ID回卷（即在<structname>pg_stat_activity</structname>视图中的autovacuum查询名以<literal>(to prevent wraparound)</literal>结尾），则autovacuum不会被自动中断。
   </para>
<!-- pgdoc-cn_end sig_en=71280232a804f5538f8217fa42597d00 -->

   <warning>
<!-- pgdoc-cn_start sig_en=8ed3714d637214249dad6485873082a3 sig_cn_org=None source=14.1 
    <para>
     Regularly running commands that acquire locks conflicting with a
     <literal>SHARE UPDATE EXCLUSIVE</literal> lock (e.g., ANALYZE) can
     effectively prevent autovacuums from ever completing.
    </para>
________________________________________________________-->
    <para>
     定期运行需要获取与<literal>SHARE UPDATE EXCLUSIVE</literal>锁冲突的锁的命令（例如ANALYZE）可能会让autovacuum始终无法完成。
    </para>
<!-- pgdoc-cn_end sig_en=8ed3714d637214249dad6485873082a3 -->
   </warning>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
<!-- pgdoc-cn_start sig_en=01193cf4174e42aa7425348662833071 sig_cn_org=None source=14.1 
  <title>Routine Reindexing</title>
________________________________________________________-->
  <title>日常重建索引</title>
<!-- pgdoc-cn_end sig_en=01193cf4174e42aa7425348662833071 -->

<!-- pgdoc-cn_start sig_en=ba3023f826cb4f2085a32cd12f9f2a22 sig_cn_org=None source=14.1 
  <indexterm zone="routine-reindex">
   <primary>reindex</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="routine-reindex">
   <primary>重建索引</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ba3023f826cb4f2085a32cd12f9f2a22 -->

<!-- pgdoc-cn_start sig_en=ac48e475ceed1184d8b18b3a557bc2bf sig_cn_org=None source=14.1 
  <para>
   In some situations it is worthwhile to rebuild indexes periodically
   with the <xref linkend="sql-reindex"/> command or a series of individual
   rebuilding steps.

  </para>
________________________________________________________-->
  <para>
   在某些情况下值得周期性地使用<xref linkend="sql-reindex"/>命令或一系列独立重构步骤来重建索引。

  </para>
<!-- pgdoc-cn_end sig_en=ac48e475ceed1184d8b18b3a557bc2bf -->

<!-- pgdoc-cn_start sig_en=9f3b6d1c9431389c060175a47f00c973 sig_cn_org=None source=14.1 
  <para>
   B-tree index pages that have become completely empty are reclaimed for
   re-use.  However, there is still a possibility
   of inefficient use of space: if all but a few index keys on a page have
   been deleted, the page remains allocated.  Therefore, a usage
   pattern in which most, but not all, keys in each range are eventually
   deleted will see poor use of space.  For such usage patterns,
   periodic reindexing is recommended.
  </para>
________________________________________________________-->
  <para>
   已经完全变成空的B树索引页面被收回重用。但是，还是有一种低效的空间利用的可能性：如果一个页面上除少量索引键之外的全部键被删除，该页面仍然被分配。因此，在这种每个范围中大部分但不是全部键最终被删除的使用模式中，可以看到空间的使用是很差的。对于这样的使用模式，推荐使用定期重新索引。
  </para>
<!-- pgdoc-cn_end sig_en=9f3b6d1c9431389c060175a47f00c973 -->

<!-- pgdoc-cn_start sig_en=3c8c3654722b795b7bc3198d6fa9c5f9 sig_cn_org=None source=14.1 
  <para>
   The potential for bloat in non-B-tree indexes has not been well
   researched.  It is a good idea to periodically monitor the index's physical
   size when using any non-B-tree index type.
  </para>
________________________________________________________-->
  <para>
   对于非B树索引可能的膨胀还没有很好地定量分析。在使用非B树索引时定期监控索引的物理尺寸是个好主意。
  </para>
<!-- pgdoc-cn_end sig_en=3c8c3654722b795b7bc3198d6fa9c5f9 -->

<!-- pgdoc-cn_start sig_en=7dba770e908d17c268cd99cebeacf3fb sig_cn_org=None source=14.1 
  <para>
   Also, for B-tree indexes, a freshly-constructed index is slightly faster to
   access than one that has been updated many times because logically
   adjacent pages are usually also physically adjacent in a newly built index.
   (This consideration does not apply to non-B-tree indexes.)  It
   might be worthwhile to reindex periodically just to improve access speed.
  </para>
________________________________________________________-->
  <para>
   还有，对于B树索引，一个新建立的索引比更新了多次的索引访问起来要略快， 因为在新建立的索引上，逻辑上相邻的页面通常物理上也相邻（这样的考虑目前并不适用于非B树索引）。仅仅为了提高访问速度也值得定期重新索引。
  </para>
<!-- pgdoc-cn_end sig_en=7dba770e908d17c268cd99cebeacf3fb -->

<!-- pgdoc-cn_start sig_en=e8ab0c05aa50b0ee93453ef53d8d311c sig_cn_org=None source=14.1 
  <para>
   <xref linkend="sql-reindex"/> can be used safely and easily in all cases.
   This command requires an <literal>ACCESS EXCLUSIVE</literal> lock by
   default, hence it is often preferable to execute it with its
   <literal>CONCURRENTLY</literal> option, which requires only a
   <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="sql-reindex"/>在所有情况下都可以安全和容易地使用。
   默认情况下，此命令需要一个<literal>ACCESS EXCLUSIVE</literal>锁，因此通常最好使用<literal>CONCURRENTLY</literal>选项执行它，该选项仅需要获取<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
 </para>
<!-- pgdoc-cn_end sig_en=e8ab0c05aa50b0ee93453ef53d8d311c -->
 </sect1>


 <sect1 id="logfile-maintenance">
<!-- pgdoc-cn_start sig_en=3686dc098a9b8f27f521bc2fc6a7314b sig_cn_org=None source=14.1 
  <title>Log File Maintenance</title>
________________________________________________________-->
  <title>日志文件维护</title>
<!-- pgdoc-cn_end sig_en=3686dc098a9b8f27f521bc2fc6a7314b -->

<!-- pgdoc-cn_start sig_en=0a7eb0bb8d1f0dd3fb11d76be63242e7 sig_cn_org=None source=14.1 
  <indexterm zone="logfile-maintenance">
   <primary>server log</primary>
   <secondary>log file maintenance</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="logfile-maintenance">
   <primary>服务器日志</primary>
   <secondary>日志文件维护</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0a7eb0bb8d1f0dd3fb11d76be63242e7 -->

<!-- pgdoc-cn_start sig_en=efadae568b64957efb58bc27bc470c5c sig_cn_org=790539696c14f3e221212dedf136c1d5 source=15.7 
  <para>
   It is a good idea to save the database server's log output
   somewhere, rather than just discarding it via <filename>/dev/null</filename>.
   The log output is invaluable when diagnosing
   problems.
  </para>
________________________________________________________-->
  <para>
   最好将数据库服务器的日志输出保存在某个地方，而不是简单地通过<filename>/dev/null</filename>丢弃。
   在诊断问题时，日志输出是非常宝贵的。
</para>
<!-- pgdoc-cn_end sig_en=efadae568b64957efb58bc27bc470c5c -->

  <note>
<!-- pgdoc-cn_start sig_en=15c90fc11258db36e8ed6e91fbbe0ca1 sig_cn_org=ea5ee8317541bb69db9823384fa65506 source=15.7 
   <para>
    The server log can contain sensitive information and needs to be protected,
    no matter how or where it is stored, or the destination to which it is routed.
    For example, some DDL statements might contain plaintext passwords or other
    authentication details. Logged statements at the <literal>ERROR</literal>
    level might show the SQL source code for applications
    and might also contain some parts of data rows. Recording data, events and
    related information is the intended function of this facility, so this is
    not a leakage or a bug. Please ensure the server logs are visible only to
    appropriately authorized people.
   </para>
________________________________________________________-->
   <para>
    服务器日志可能包含敏感信息，需要受到保护，无论存储在何处，或者发送到何处。
    例如，一些DDL语句可能包含明文密码或其他身份验证详细信息。在<literal>ERROR</literal>级别记录的语句可能显示应用程序的SQL源代码，
    也可能包含部分数据行。记录数据、事件和相关信息是此设施的预期功能，因此这不是泄漏或错误。请确保服务器日志仅对适当授权的人员可见。
   </para>
<!-- pgdoc-cn_end sig_en=15c90fc11258db36e8ed6e91fbbe0ca1 -->
  </note>

<!-- pgdoc-cn_start sig_en=e52c83a2a7ca3f9b803e1a96d727da8e sig_cn_org=64794f47afb087f68a3363759943eda4 source=15.7 
  <para>
   Log output tends to be voluminous
   (especially at higher debug levels) so you won't want to save it
   indefinitely.  You need to <emphasis>rotate</emphasis> the log files so that
   new log files are started and old ones removed after a reasonable
   period of time.
  </para>
________________________________________________________-->
  <para>
   日志输出往往是庞大的（特别是在更高的调试级别），因此您不希望无限期保存它。
   您需要<emphasis>轮换（rotate）</emphasis>日志文件，以便在合理的时间后启动新的日志文件并删除旧的日志文件。
</para>
<!-- pgdoc-cn_end sig_en=e52c83a2a7ca3f9b803e1a96d727da8e -->

<!-- pgdoc-cn_start sig_en=2cd3470ee0f0b6b707db4e40cedd4793 sig_cn_org=None source=14.1 
  <para>
   If you simply direct the <systemitem>stderr</systemitem> of
   <command>postgres</command> into a
   file, you will have log output, but
   the only way to truncate the log file is to stop and restart
   the server. This might be acceptable if you are using
   <productname>PostgreSQL</productname> in a development environment,
   but few production servers would find this behavior acceptable.
  </para>
________________________________________________________-->
  <para>
   如果你简单地把<command>postgres</command>的<systemitem>stderr</systemitem>定向到一个文件中，你会得到日志输出，但是截断该日志文件的唯一方法是停止并重起服务器。这样做对于开发环境中使用的<productname>PostgreSQL</productname>可能是可接受的，但是你肯定不想在生产环境上这么干。
  </para>
<!-- pgdoc-cn_end sig_en=2cd3470ee0f0b6b707db4e40cedd4793 -->

<!-- pgdoc-cn_start sig_en=fa536e6692ea3583dbea311c8ca1aef0 sig_cn_org=None source=14.1 
  <para>
   A better approach is to send the server's
   <systemitem>stderr</systemitem> output to some type of log rotation program.
   There is a built-in log rotation facility, which you can use by
   setting the configuration parameter <varname>logging_collector</varname> to
   <literal>true</literal> in <filename>postgresql.conf</filename>.  The control
   parameters for this program are described in <xref
   linkend="runtime-config-logging-where"/>. You can also use this approach
   to capture the log data in machine readable <acronym>CSV</acronym>
   (comma-separated values) format.
  </para>
________________________________________________________-->
  <para>
   一个更好的办法是把服务器的<systemitem>stderr</systemitem>输出发送到某种日志轮转程序里。我们有一个内建的日志轮转程序，你可以通过在 <filename>postgresql.conf</filename>里设置配置参数<varname>logging_collector</varname>为<literal>true</literal>的办法启用它。该程序的控制参数在 <xref linkend="runtime-config-logging-where"/>里描述。你也可以使用这种方法把日志数据捕捉成机器可读的<acronym>CSV</acronym>（逗号分隔值）格式。
  </para>
<!-- pgdoc-cn_end sig_en=fa536e6692ea3583dbea311c8ca1aef0 -->

<!-- pgdoc-cn_start sig_en=4dd30f1497f21eab739da3d455e5304d sig_cn_org=None source=14.1 
  <para>
   Alternatively, you might prefer to use an external log rotation
   program if you have one that you are already using with other
   server software. For example, the <application>rotatelogs</application>
   tool included in the <productname>Apache</productname> distribution
   can be used with <productname>PostgreSQL</productname>.  One way to
   do this is to pipe the server's
   <systemitem>stderr</systemitem> output to the desired program.
   If you start the server with
   <command>pg_ctl</command>, then <systemitem>stderr</systemitem>
   is already redirected to <systemitem>stdout</systemitem>, so you just need a
   pipe command, for example:

<programlisting>
pg_ctl start | rotatelogs /var/log/pgsql_log 86400
</programlisting>
  </para>
________________________________________________________-->
  <para>
   另外，如果在你已经使用的其他服务器软件中有一个外部日志轮转程序，你可能更喜欢使用它。 比如，包含在<productname>Apache</productname>发布里的<application>rotatelogs</application>工具就可以用于<productname>PostgreSQL</productname>。要做到这一点，方法之一是把服务器的<systemitem>stderr</systemitem>用管道重定向到要用的程序。 如果你用<command>pg_ctl</command>启动服务器，那么<systemitem>stderr</systemitem>已经重定向到<systemitem>stdout</systemitem>， 因此你只需要一个管道命令，比如：

<programlisting>
pg_ctl start | rotatelogs /var/log/pgsql_log 86400
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=4dd30f1497f21eab739da3d455e5304d -->

<!-- pgdoc-cn_start sig_en=559aced90dcfc3f4f110426f31d8b032 sig_cn_org=None source=14.1 
  <para>
   You can combine these approaches by setting up <application>logrotate</application>
   to collect log files produced by <productname>PostgreSQL</productname> built-in
   logging collector.  In this case, the logging collector defines the names and
   location of the log files, while <application>logrotate</application>
   periodically archives these files.  When initiating log rotation,
   <application>logrotate</application> must ensure that the application
   sends further output to the new file.  This is commonly done with a
   <literal>postrotate</literal> script that sends a <literal>SIGHUP</literal>
   signal to the application, which then reopens the log file.
   In <productname>PostgreSQL</productname>, you can run <command>pg_ctl</command>
   with the <literal>logrotate</literal> option instead.  When the server receives
   this command, the server either switches to a new log file or reopens the
   existing file, depending on the logging configuration
   (see <xref linkend="runtime-config-logging-where"/>).
  </para>
________________________________________________________-->
  <para>
   您可以通过设置<application>logrotate</application>来收集由<productname>PostgreSQL</productname>内置日志收集器生成的日志文件来组合这些方法。在这种情况下，日志收集器定义日志文件的名称和位置，而<application>logrotate</application> 则定期归档这些文件。启动日志轮转时，<application>logrotate</application>必须确保应用程序将进一步的输出发送到新文件。这通常是通过<literal>postrotate</literal>脚本完成的，该脚本向应用程序发送<literal>SIGHUP</literal>信号，使其重新打开日志文件。在<productname>PostgreSQL</productname>中，您可以使用<literal>logrotate</literal>选项运行<command>pg_ctl</command>。服务器收到此命令后，服务器将切换到新的日志文件或重新打开现有文件，具体取决于日志记录配置（请参见<xref linkend="runtime-config-logging-where"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=559aced90dcfc3f4f110426f31d8b032 -->

  <note>
<!-- pgdoc-cn_start sig_en=8968098adee6b4fb688d94f7c547d527 sig_cn_org=None source=14.1 
   <para>
    When using static log file names, the server might fail to reopen the log
    file if the max open file limit is reached or a file table overflow occurs.
    In this case, log messages are sent to the old log file until a
    successful log rotation. If <application>logrotate</application> is
    configured to compress the log file and delete it, the server may lose
    the messages logged in this time frame. To avoid this issue, you can
    configure the logging collector to dynamically assign log file names
    and use a <literal>prerotate</literal> script to ignore open log files.
    </para>
________________________________________________________-->
   <para>
    使用静态日志文件名时，如果达到最大打开文件数限制或发生文件表溢出，则服务器可能无法重新打开日志文件。
    在这种情况下，日志消息将发送到旧的日志文件，直到成功进行日志轮转为止。
    如果将<application>logrotate</application>配置为压缩日志文件并将其删除，则服务器可能会丢失此时间范围内记录的消息。
    为避免此问题，可以将日志收集器配置为动态分配日志文件名，并使用<literal>prerotate</literal>脚本忽略打开的日志文件。
    </para>
<!-- pgdoc-cn_end sig_en=8968098adee6b4fb688d94f7c547d527 -->
  </note>

<!-- pgdoc-cn_start sig_en=94b4976e09713f642c50d98a00923fe1 sig_cn_org=None source=14.1 
  <para>
   Another production-grade approach to managing log output is to
   send it to <application>syslog</application> and let
   <application>syslog</application> deal with file rotation. To do this, set the
   configuration parameter <varname>log_destination</varname> to <literal>syslog</literal>
   (to log to <application>syslog</application> only) in
   <filename>postgresql.conf</filename>. Then you can send a <literal>SIGHUP</literal>
   signal to the <application>syslog</application> daemon whenever you want to force it
   to start writing a new log file.  If you want to automate log
   rotation, the <application>logrotate</application> program can be
   configured to work with log files from
   <application>syslog</application>.
  </para>
________________________________________________________-->
  <para>
   另外一种生产级的管理日志输出的方法就是把它们发送给<application>syslog</application>，让<application>syslog</application>处理文件轮转。 要利用这个工具，我们需要设置<filename>postgresql.conf</filename>里的<varname>log_destination</varname>配置参数设置为<literal>syslog</literal>（记录<literal>syslog</literal>日志）。然后在你想强迫<application>syslog</application>守护进程开始写入一个新日志文件的时候， 你就可以发送一个 <literal>SIGHUP</literal>信号给它。 如果你想自动进行日志轮转，可以配置<application>logrotate</application>程序处理 来自<application>syslog</application>的日志文件。
  </para>
<!-- pgdoc-cn_end sig_en=94b4976e09713f642c50d98a00923fe1 -->

<!-- pgdoc-cn_start sig_en=50362a1cb1f7f053b85ff5d436944353 sig_cn_org=None source=14.1 
  <para>
   On many systems, however, <application>syslog</application> is not very reliable,
   particularly with large log messages; it might truncate or drop messages
   just when you need them the most.  Also, on <productname>Linux</productname>,
   <application>syslog</application> will flush each message to disk, yielding poor
   performance.  (You can use a <quote><literal>-</literal></quote> at the start of the file name
   in the <application>syslog</application> configuration file to disable syncing.)
  </para>
________________________________________________________-->
  <para>
   不过，在很多系统上，<application>syslog</application>不是非常可靠，特别是在面对大量日志消息的情况下； 它可能在你最需要那些消息的时候截断或者丢弃它们。另外，在<productname>Linux</productname>，<application>syslog</application>会把每个消息刷写到磁盘上， 这将导致很差的性能（你可以在<application>syslog</application>配置文件里面的文件名开头使用一个<quote><literal>-</literal></quote>来禁用这种行为）。
  </para>
<!-- pgdoc-cn_end sig_en=50362a1cb1f7f053b85ff5d436944353 -->

<!-- pgdoc-cn_start sig_en=8d66c6f58294c389192e38709ed3d3bf sig_cn_org=None source=14.1 
  <para>
   Note that all the solutions described above take care of starting new
   log files at configurable intervals, but they do not handle deletion
   of old, no-longer-useful log files.  You will probably want to set
   up a batch job to periodically delete old log files.  Another possibility
   is to configure the rotation program so that old log files are overwritten
   cyclically.
  </para>
________________________________________________________-->
  <para>
   请注意上面描述的所有解决方案关注的是在可配置的间隔上开始一个新的日志文件， 但它们并没有处理对旧的、不再需要的日志文件的删除。你可能还需要设置一个批处理任务来定期地删除旧日志文件。 另一种可能的方法是配置日志轮转程序，让它循环地覆盖旧的日志文件。
  </para>
<!-- pgdoc-cn_end sig_en=8d66c6f58294c389192e38709ed3d3bf -->

<!-- pgdoc-cn_start sig_en=18571719307f6986f5471bc3c5452321 sig_cn_org=None source=14.1 
  <para>
   <ulink url="https://pgbadger.darold.net/"><productname>pgBadger</productname></ulink>
   is an external project that does sophisticated log file analysis.
   <ulink
   url="https://bucardo.org/check_postgres/"><productname>check_postgres</productname></ulink>
   provides Nagios alerts when important messages appear in the log
   files, as well as detection of many other extraordinary conditions.
  </para>
________________________________________________________-->
  <para>
   <ulink url="https://pgbadger.darold.net/"><productname>pgBadger</productname></ulink>是一个外部项目，它可以进行日志文件的深度分析。
   <ulink
   url="https://bucardo.org/check_postgres/"><productname>check_postgres</productname></ulink>可在重要消息出现在日志文件中时向Nagios提供警告，也可以探测很多其他的特别情况。
  </para>
<!-- pgdoc-cn_end sig_en=18571719307f6986f5471bc3c5452321 -->
 </sect1>
</chapter>
